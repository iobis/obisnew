<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="/assets/main.css" />
    <title>
    
        Extracting and Enriching OBIS Data with R | Ocean Biodiversity Information System (OBIS)
    
    </title>
</head>


  <body>
    <nav class="navbar navbar-expand-lg navbar-light">
    <div class="container">
      <a class="navbar-brand" href="/">Ocean Biodiversity Information System</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
          
          <li class="nav-item">
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Who we are
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              
                <li><a class="dropdown-item" href="/about/visionmission">Vision and mission</a></li>
              
                <li><a class="dropdown-item" href="/about/nodes">Nodes</a></li>
              
                <li><a class="dropdown-item" href="/about/governance">Governance</a></li>
              
                <li><a class="dropdown-item" href="/contact">Team and contacts</a></li>
              
                <li><a class="dropdown-item" href="/about/partner">Become a partner</a></li>
              
            </ul>
            
          </li>
          
          <li class="nav-item">
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                What we do
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              
                <li><a class="dropdown-item" href="/whatwedo/core-activities">Core activities</a></li>
              
                <li><a class="dropdown-item" href="/whatwedo/impact">Impact</a></li>
              
                <li><a class="dropdown-item" href="/whatwedo/objectives">Objectives</a></li>
              
                <li><a class="dropdown-item" href="/usecases">Use cases</a></li>
              
            </ul>
            
          </li>
          
          <li class="nav-item">
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Data
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              
                <li><a class="dropdown-item" href="/search">Access data</a></li>
              
                <li><a class="dropdown-item" href="/data/contribute">Contribute data</a></li>
              
                <li><a class="dropdown-item" href="/data/quality">Quality control</a></li>
              
                <li><a class="dropdown-item" href="/data/cite">How to cite OBIS</a></li>
              
                <li><a class="dropdown-item" href="/data/datapolicy">Data policy</a></li>
              
            </ul>
            
          </li>
          
          <li class="nav-item">
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Community
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              
                <li><a class="dropdown-item" href="/news">News</a></li>
              
                <li><a class="dropdown-item" href="/community/coordinationgroups">Coordination groups</a></li>
              
                <li><a class="dropdown-item" href="https://obis.discourse.group/">OBIS Discourse</a></li>
              
            </ul>
            
          </li>
          
          <li class="nav-item">
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Resources
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              
                <li><a class="dropdown-item" href="https://manual.obis.org">OBIS manual</a></li>
              
                <li><a class="dropdown-item" href="https://github.com/iobis">OBIS GitHub</a></li>
              
                <li><a class="dropdown-item" href="https://classroom.oceanteacher.org/tag/index.php?tc=3&tag=ioc_programme%3A%3Aobis">OBIS courses on OTGA</a></li>
              
                <li><a class="dropdown-item" href="https://docs.gbif.org/publishing-dna-derived-data/en/">DNA derived data publishing</a></li>
              
                <li><a class="dropdown-item" href="https://www.youtube.com/playlist?list=PLlgUwSvpCFS4TS7ZN0fhByj_3EBZ5lXbF">OBIS YouTube</a></li>
              
            </ul>
            
          </li>
          
          <li class="nav-item ms-2">
            <a class="btn btn-primary nav-link" href="/search">Search</a>
          </li>
        </ul>
      </div>

      <!-- <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="#">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Contribute</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Data</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Resources
            </a>
            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              <li><a class="dropdown-item" href="#">Manual</a></li>
              <li><a class="dropdown-item" href="#">Outreach</a></li>
              <li><a class="dropdown-item" href="#">Publications</a></li>
            </ul>
          </li>
        </ul>
      </div> -->

    </div>
  </nav>

    <div class="container container-post mt-5">
        <p>News</p>
        <h1>Extracting and Enriching OBIS Data with R</h1>
        
        <ul>
  <li><a href="#introduction">Introduction and Rationale</a></li>
  <li><a href="#starting">Starting point, journey, and destination</a></li>
  <li><a href="#taxonomy">Taxonomy</a>
    <ul>
      <li><a href="#singletaxon">Check taxonomy of a single taxon</a></li>
      <li><a href="#listoftaxa">Check a list of taxa</a></li>
    </ul>
  </li>
  <li><a href="#gettingoccurrences">Getting occurrences</a>
    <ul>
      <li><a href="#singlespecies">Getting OBIS records for a single species</a></li>
    </ul>
  </li>
  <li><a href="#understanding">Understanding occurrence records</a>
    <ul>
      <li><a href="#examining">Examining OBIS records in more detail</a></li>
    </ul>
  </li>
  <li><a href="#enriching">Enriching OBIS data</a>
    <ul>
      <li><a href="#sampledepths">Matching sample depth to bathymetry</a></li>
      <li><a href="#temperature">Matching occurrences to temperature in space and time</a></li>
      <li><a href="#local">Matching occurrences to local spatial datasets</a></li>
    </ul>
  </li>
  <li><a href="#geography">Adding geography</a>
    <ul>
      <li><a href="#specificregion">Getting occurrence data for a specific region</a></li>
      <li><a href="#specieslist">Getting a species list for a specific region</a></li>
      <li><a href="#regionnames">Finding appropriate region names</a></li>
      <li><a href="#globaldata">Summarising global data by region</a></li>
      <li><a href="#environmental">Combining Regional and Environmental Data</a></li>
    </ul>
  </li>
  <li><a href="#coda">Coda</a></li>
</ul>

<p><a class="anchor" name="introduction"></a></p>

<h2 id="introduction-and-rationale">Introduction and Rationale</h2>

<p>Programmatic access to biodiversity data is revolutionising large-scale, reproducible biodiversity research. In this series of tutorials we show how <a href="http://www.iobis.org/">OBIS</a> data can be accessed programmatically from within the Open Source statistical computing environment <a href="https://www.r-project.org/">R</a>. This exposes OBIS data to the full range of manipulations, visualisations, and statistical analyses provided by R. It also makes it possible to link and enrich OBIS data, combining it with other environmental, geographic, and biological data sets to better understand the distribution and dynamics of marine biodiversity. The examples we provide here constitute what we consider to be among the most common desired use cases of OBIS data, and they depend upon the considerable efforts of many in the R community who have contributed the useful packages which we have used. In particular, <a href="http://ropensci.org">ROpenSci</a> provides a wide range of open tools for open science, and our work has benefited greatly from working with and learning from them. Our hope is that other users will build on these examples, adapting and improving them to fit a range of research and policy scenarios.</p>

<p><strong>Disclaimer</strong>: In all of the examples used here, data taken as is. Where possible we have alerted users to possible quality control issues but we cannot take responsibility for errors in the data. The code provides example implementations of the various use cases we envisage, but these will certainly not be the only ways to implement these methods, and may not be the most efficient or robust. Our code lives on GitHub here and we welcome suggestions for how to improve it.</p>

<p>The examples we provide build on the work of others, and use a large number of existing R packages. You will need to ensure that all of these (and their dependencies) are installed in order for the code in these tutorials to run. Most can be installed from CRAN in the standard manner, e.g. <code class="language-plaintext highlighter-rouge">install.packages("package_name")</code> but some are development versions which need to be installed from GitHub, for which you will need the devtools library installed (<code class="language-plaintext highlighter-rouge">install.packages("devtools")</code> if you need).</p>

<p>The packages we use development versions for need to be installed like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">devtools</span><span class="o">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">"ropenscilabs/mregions"</span><span class="p">)</span><span class="w">
</span><span class="n">devtools</span><span class="o">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">"iobis/robis"</span><span class="p">)</span><span class="w">
</span><span class="n">devtools</span><span class="o">::</span><span class="n">install_github</span><span class="p">(</span><span class="s2">"ropensci/taxizesoap"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>If you have problems installing taxizesoap see <a href="https://github.com/ropensci/taxizesoap">https://github.com/ropensci/taxizesoap</a>. Once all packages are installed, load them:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">taxizesoap</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">robis</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ggmap</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ncdf4</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">stringr</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">readr</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">pryr</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">marmap</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">lubridate</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">broom</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">mregions</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgeos</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>All data for this tutorial can be at <a href="https://github.com/iobis/training/tree/master/sorbycollection">https://github.com/iobis/training/tree/master/sorbycollection</a>.</p>

<hr />

<p><a class="anchor" name="starting"></a></p>

<h2 id="starting-point-journey-and-destination">Starting point, journey, and destination</h2>

<p>We choose to start with a list of taxonomic names of unknown quality. In our experience this is a common situation: you may have obtained a dataset from a collaborator, or from the literature, which documents some characteristics of a number of taxa, and you wish to tidy up this dataset and enrich it with some occurrence data. The taxon list we have chosen is one very local to us in landlocked Sheffield. On the wall in the <a href="http://www.sheffield.ac.uk/aps">Department of Animal and Plant Sciences at the University of Sheffield</a> is a display case that is all too easy to walk past - some of us have been walking past it every day for years.</p>

<p><img src="/images/sorbycollection/adb1-small.png" alt="" /></p>

<p><br />
Light it up and examine the specimens though and they are revealed to be spectacular:</p>

<p><img src="/images/sorbycollection/adb2.png" alt="" /></p>

<p><br />
This collection was created by the 19th Century Sheffield microscopist, geologist, and naturalist <a href="https://www.sheffield.ac.uk/aps/about/sorby">Henry Clifton Sorby</a>, using a technique for mounting entire specimens that he perfected - and one which proved so complex and laborious that it was not widely taken up, despite the beautiful results. The 80 specimens in the collection provide a useful test-case for modern biodiversity computational methods, as there is considerable taxonomic breadth (including fish as well as numerous invertebrate groups), but the names recorded are of inconsistent taxonomic rank, and - having been recorded well over 100 years ago - many are almost certainly no longer current.
The first stage of our journey then - after transcribing the names into a spreadsheet - is to check their <strong>taxonomy</strong>. Once we are confident in the names, and have restricted the dataset to a suitable taxonomic rank (species, here), we can start to examine <strong>occurrences</strong> as recorded in OBIS. Once we have done this, for individual species and for groups of species, we can start to enrich the basic occurrence data in various ways. In particular, we show how to match the occurrences to various <strong>environmental layers</strong>, including depth and climate. And we show how to perform more sophisticated geographic searches using <strong>georeferenced boundaries and regions</strong>.</p>

<hr />

<p><a class="anchor" name="taxonomy"></a></p>

<h2 id="taxonomy">Taxonomy</h2>

<p>OBIS uses the <a href="http://www.marinespecies.org">WoRMS</a> standard taxonomy. This means that names within OBIS’s realisation of the WoRMS Aphia database will be matched correctly - that is, occurrence records returned for an accepted taxonomic name will include records for unaccepted synonyms, and unaccepted names will be amalgamated to the current accepted name. However, it is often worthwhile to check your taxonomy in advance, especially if you are working with large sets of taxa (as macroecologists frequently are), or with unusual sets of names, such as the Sorby Collection. This will help to identify any potential problems or ambiguities, and also gives more flexibility for identifying and dealing with minor typos and misspellings. WoRMS provides options for matching relatively small lists of taxa (&lt;1500 rows) via its <a href="http://www.marinespecies.org/aphia.php?p=match">website</a>, with larger matches possible via the <a href="http://www.lifewatch.be/data-services/">LifeWatch taxonomic backbone</a>. For large and/or complex lists of taxa, for instance if you have little confidence in the names supplied, then working via WoRMS or LifeWatch in this way is probably a good idea. Certainly in our experience any sufficiently long list of taxa is going to require a certain amount of user interaction and informed or expert judgement in order to arrive at an acceptable taxonomic match. However, it is possible to rapidly match names to WoRMS by calling the WoRMS web services directly from within R, using the <a href="https://github.com/ropensci/taxizesoap">taxizesoap</a> package. This provides much of the WoRMS taxon matching functionality, for instance fuzzy (or approximate) name matching is possible. This can provide a convenient, scripted way of generating a taxonomically robust dataset, and we demonstrate its use here.</p>

<p>First, read in a species list - here, the Sorby collection list, data available <a href="https://drive.google.com/file/d/0B7OcGQ7KA64UdzNDYTYxUWNtTEE/view?usp=sharing">here</a>. Note this uses the <code class="language-plaintext highlighter-rouge">read_csv</code> function from the <code class="language-plaintext highlighter-rouge">readr</code> package, which has some speed and parsing advantages over the base <code class="language-plaintext highlighter-rouge">read.csv</code> function. <code class="language-plaintext highlighter-rouge">read_csv2</code> is appropriate if you are dealing with a csv from a country which uses ‘,’ as a decimal separator. This assumes that the <code class="language-plaintext highlighter-rouge">sorby_collection</code> data is in a subfolder data within your working directory:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_csv</span><span class="p">(</span><span class="s2">"data/sorby_collection.csv"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Have quick look at the data - should be a single variable, taxon_name:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glimpse</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 50
## Variables: 1
## $ taxon_name &lt;chr&gt; "Actinoloba dianthus", "Alloteuthis media", "Aphrod...
</code></pre></div></div>

<p><a class="anchor" name="singletaxon"></a></p>

<h3 id="check-taxonomy-of-a-single-taxon">Check taxonomy of a single taxon</h3>
<p>Select the first species, <em>Actinoloba dianthus</em>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_sp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">taxon_name</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>Get AphiaID for this species. Here we set <code class="language-plaintext highlighter-rouge">accepted = FALSE</code> so that we are not restricted to accepted IDs (for instance, with <code class="language-plaintext highlighter-rouge">accepted = TRUE</code> no ID would be found for <em>Actinoloba dianthus</em>):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_sp_aphia</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_wormsid</span><span class="p">(</span><span class="n">searchterm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_sp</span><span class="p">,</span><span class="w"> </span><span class="n">accepted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Retrieving data for taxon 'Actinoloba dianthus'
</code></pre></div></div>
<p>The full WoRMS record for this species can then be obtained from the ID as:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_sp_taxo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">worms_records</span><span class="p">(</span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_sp_aphia</span><span class="p">,</span><span class="w"> </span><span class="n">marine_only</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Note that you can choose whether to restrict the search to species classified as marine by WoRMS by setting the marine_only argument.</p>

<p>Use <code class="language-plaintext highlighter-rouge">glimpse()</code> for a quick overview of the returned dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glimpse</span><span class="p">(</span><span class="n">my_sp_taxo</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 1
## Variables: 26
## $ inputid         &lt;chr&gt; "742385"
## $ AphiaID         &lt;chr&gt; "742385"
## $ url             &lt;chr&gt; "http://www.marinespecies.org/aphia.php?p=taxd...
## $ scientificname  &lt;chr&gt; "Actinoloba dianthus"
## $ authority       &lt;chr&gt; "de Blainville, 1830"
## $ rank            &lt;chr&gt; "Species"
## $ status          &lt;chr&gt; "unaccepted"
## $ unacceptreason  &lt;chr&gt; NA
## $ valid_AphiaID   &lt;chr&gt; "100982"
## $ valid_name      &lt;chr&gt; "Metridium senile"
## $ valid_authority &lt;chr&gt; "(Linnaeus, 1761)"
## $ kingdom         &lt;chr&gt; "Animalia"
## $ phylum          &lt;chr&gt; "Cnidaria"
## $ class           &lt;chr&gt; "Anthozoa"
## $ order           &lt;chr&gt; "Actiniaria"
## $ family          &lt;chr&gt; "Actinostolidae"
## $ genus           &lt;chr&gt; "Actinoloba"
## $ citation        &lt;chr&gt; "Fautin, D. (2013). Actinoloba dianthus de Bla...
## $ lsid            &lt;chr&gt; "urn:lsid:marinespecies.org:taxname:742385"
## $ isMarine        &lt;chr&gt; "1"
## $ isBrackish      &lt;chr&gt; NA
## $ isFreshwater    &lt;chr&gt; NA
## $ isTerrestrial   &lt;chr&gt; NA
## $ isExtinct       &lt;chr&gt; NA
## $ match_type      &lt;chr&gt; "exact"
## $ modified        &lt;chr&gt; "2013-10-04T10:33:40Z"
</code></pre></div></div>

<p>You can see from <code class="language-plaintext highlighter-rouge">status</code> that this name / ID is unaccepted; the <code class="language-plaintext highlighter-rouge">valid_name</code> is <em>Metridium senile</em>. You get the taxonomic hierarchy for this accepted name, and some habitat information (1 in <code class="language-plaintext highlighter-rouge">isMarine</code> shows that it is a marine species).</p>

<p><a class="anchor" name="listoftaxa"></a></p>

<h3 id="check-a-list-of-taxa">Check a list of taxa</h3>

<p>More frequently you are likely to check want to check a list of taxa. To do that, simply pass the full list to the above functions. This will take a few seconds to run through the whole list. To avoid multiple calls for the same name, you should ensure your list contains each unique taxon name only once. In this example each name does only appear once in the sorby_coll, i.e.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">identical</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">taxon_name</span><span class="p">)),</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">taxon_name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] TRUE
</code></pre></div></div>
<p>If that is not the case, create a taxon list like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_taxa</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">taxon_name</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Then get AphiaIDs (this takes me ~20s to run):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">system.time</span><span class="p">(</span><span class="w">
  </span><span class="n">all_spp_aphia</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_wormsid</span><span class="p">(</span><span class="n">searchterm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_taxa</span><span class="p">,</span><span class="w"> </span><span class="n">accepted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    user  system elapsed 
##  12.928   0.249  21.526
</code></pre></div></div>
<p>You can check how many names were able to be linked to an AphiaID:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="nf">attr</span><span class="p">(</span><span class="n">all_spp_aphia</span><span class="p">,</span><span class="w"> </span><span class="s2">"match"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##     found not found 
##        47         3
</code></pre></div></div>
<p>So, all but three names were effectively matched. We will return to the 3 missing ones below. For now, add the returned AphiaIDs into our original dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="o">$</span><span class="n">aphia_id</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.vector</span><span class="p">(</span><span class="n">all_spp_aphia</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Sometimes multiple IDs will match a search term. This is especially likely to be the case if you search for a general common name, such as ‘cod’ - for example:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aphia_eg</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_wormsid</span><span class="p">(</span><span class="n">searchterm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cod"</span><span class="p">,</span><span class="w"> </span><span class="n">searchtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"common"</span><span class="p">,</span><span class="w"> </span><span class="n">accepted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Retrieving data for taxon 'cod'
## 
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    AphiaID                     target     status    rank valid_AphiaID
## 1   105836           Alopias vulpinus   accepted Species        105836
## 2   158939                 Anas acuta   accepted Species        158939
## 3   126486          Antimora rostrata   accepted Species        126486
## 4   272297        Arctogadus borisovi   accepted Species        272297
## 5   126432       Arctogadus glacialis   accepted Species        126432
## 6   126433           Boreogadus saida   accepted Species        126433
## 7   126433           Boreogadus saida   accepted Species        126433
## 8   279397        Bothrocara brunneum   accepted Species        279397
## 9   234593           Bothrocara molle   accepted Species        234593
## 10  279400        Bothrocara pusillum   accepted Species        279400
## 11  313426       Bothrocara remigerum unaccepted Species        234593
## 12  126431     Bregmaceros atlanticus   accepted Species        126431
## 13  272290    Bregmaceros bathymaster   accepted Species        272290
## 14  158924        Bregmaceros cantori   accepted Species        158924
## 15  272291         Bregmaceros houdei   accepted Species        272291
## 16  158925  Bregmaceros macclellandii unaccepted Species        217740
## 17  217742     Bregmaceros mcclelandi unaccepted Species        217740
## 18  125468            Bregmacerotidae   accepted  Family        125468
## 19  151407            Champsodontidae   accepted  Family        151407
## 20  234518            Channichthyidae   accepted  Family        234518
## 21  137071          Clangula hyemalis   accepted Species        137071
## 22  218135         Cociella crocodila unaccepted Species        398453
## 23  145079               Codium bursa   accepted Species        145079
## 24  344030         Crocodylus porosus   accepted Species        344030
## 25  280501  Derepodichthys alepidotus   accepted Species        280501
## 26  254537          Eleginus gracilis   accepted Species        254537
## 27  267012             Euclichthyidae   accepted  Family        267012
## 28  158964           Gadella imberbis   accepted Species        158964
## 29  125469                    Gadidae   accepted  Family        125469
## 30  254538        Gadus macrocephalus   accepted Species        254538
## 31  126436               Gadus morhua   accepted Species        126436
## 32  126436               Gadus morhua   accepted Species        126436
## 33  158926                 Gadus ogac   accepted Species        158926
## 34  234704 Gobionotothen gibberifrons   accepted Species        234704
## 35  276514         Gobiosoma robustum   accepted Species        276514
## 36  126489      Halargyreus johnsonii   accepted Species        126489
## 37  232053       Haliaeetus albicilla   accepted Species        232053
## 38  232053       Haliaeetus albicilla   accepted Species        232053
## 39  232053       Haliaeetus albicilla   accepted Species        232053
## 40  144483              Halimeda tuna   accepted Species        144483
## 41  254960           Inia geoffrensis   accepted Species        254960
## 42  158979       Laemonema barbatulum   accepted Species        158979
## 43  217733         Lepidion ensiferus   accepted Species        217733
## 44  126493             Lepidion eques   accepted Species        126493
## 45  234788 Lepidonotothen squamifrons   accepted Species        234788
## 46  126555        Lophius piscatorius   accepted Species        126555
## 47  126103                Lycenchelys   accepted   Genus        126103
## 48  402539      Lycenchelys crotalina unaccepted Species        254592
## 49  274067        Lycenchelys jordani   accepted Species        274067
## 50  159257       Lycenchelys paxillus   accepted Species        159257
##                    valid_name
## 1            Alopias vulpinus
## 2                  Anas acuta
## 3           Antimora rostrata
## 4         Arctogadus borisovi
## 5        Arctogadus glacialis
## 6            Boreogadus saida
## 7            Boreogadus saida
## 8         Bothrocara brunneum
## 9            Bothrocara molle
## 10        Bothrocara pusillum
## 11           Bothrocara molle
## 12     Bregmaceros atlanticus
## 13    Bregmaceros bathymaster
## 14        Bregmaceros cantori
## 15         Bregmaceros houdei
## 16    Bregmaceros mcclellandi
## 17    Bregmaceros mcclellandi
## 18            Bregmacerotidae
## 19            Champsodontidae
## 20            Channichthyidae
## 21          Clangula hyemalis
## 22        Cociella crocodilus
## 23               Codium bursa
## 24         Crocodylus porosus
## 25  Derepodichthys alepidotus
## 26          Eleginus gracilis
## 27             Euclichthyidae
## 28           Gadella imberbis
## 29                    Gadidae
## 30        Gadus macrocephalus
## 31               Gadus morhua
## 32               Gadus morhua
## 33                 Gadus ogac
## 34 Gobionotothen gibberifrons
## 35         Gobiosoma robustum
## 36      Halargyreus johnsonii
## 37       Haliaeetus albicilla
## 38       Haliaeetus albicilla
## 39       Haliaeetus albicilla
## 40              Halimeda tuna
## 41           Inia geoffrensis
## 42       Laemonema barbatulum
## 43         Lepidion ensiferus
## 44             Lepidion eques
## 45 Lepidonotothen squamifrons
## 46        Lophius piscatorius
## 47                Lycenchelys
## 48     Lycenchelys crotalinus
## 49        Lycenchelys jordani
## 50       Lycenchelys paxillus
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## More than one WoRMS ID found for taxon 'cod'!
## 
##             Enter rownumber of taxon (other inputs will return 'NA'):
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Returned 'NA'!
</code></pre></div></div>
<p>Here, by default you will be asked to select one from the options provided, in interactive mode. Here I might chose option 31, if I know I am interested in Atlantic Cod, <em>Gadus morhua</em>. If you are running through a large list of species this interactivity can be inconvenient. In that case, you can set <code class="language-plaintext highlighter-rouge">ask = FALSE</code> in which case the function returns NA as an Aphia ID, but records the fact that multiple matches were found in the <code class="language-plaintext highlighter-rouge">match</code> attribute, e.g.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aphia_eg</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_wormsid</span><span class="p">(</span><span class="n">searchterm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cod"</span><span class="p">,</span><span class="w"> </span><span class="n">searchtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"common"</span><span class="p">,</span><span class="w"> </span><span class="n">accepted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">ask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Retrieving data for taxon 'cod'
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">attr</span><span class="p">(</span><span class="n">aphia_eg</span><span class="p">,</span><span class="w"> </span><span class="s2">"match"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "multi match"
</code></pre></div></div>
<p>These cases can then be dealt with individually by the user. Note that when multiple matches are found, only first 50 will be returned, so it really does pay to make your taxon list as precise as possible, and to search on scientific rather than common names, especially if you have a large number of taxa to work through. (It is possible to overcome the 50 limit by setting an offset in <code class="language-plaintext highlighter-rouge">worms_records</code>, e.g. to return names starting at the 50th, but this is not covered here). 
This gets the full worms_records for each species for which an AphiaID was found:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">all_spp_taxa</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">worms_records</span><span class="p">(</span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">aphia_id</span><span class="p">,</span><span class="w"> </span><span class="n">marine_only</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">))</span><span class="w">
</span><span class="n">glimpse</span><span class="p">(</span><span class="n">all_spp_taxa</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 47
## Variables: 26
## $ inputid         &lt;chr&gt; "742385", "153134", "231869", "129868", "10371...
## $ AphiaID         &lt;chr&gt; "742385", "153134", "231869", "129868", "10371...
## $ url             &lt;chr&gt; "http://www.marinespecies.org/aphia.php?p=taxd...
## $ scientificname  &lt;chr&gt; "Actinoloba dianthus", "Alloteuthis media", "A...
## $ authority       &lt;chr&gt; "de Blainville, 1830", "(Linnaeus, 1758)", "(L...
## $ rank            &lt;chr&gt; "Species", "Species", "Species", "Species", "S...
## $ status          &lt;chr&gt; "unaccepted", "accepted", "unaccepted", "accep...
## $ unacceptreason  &lt;chr&gt; NA, NA, "lapsus calami", NA, NA, NA, NA, "orig...
## $ valid_AphiaID   &lt;chr&gt; "100982", "153134", "129840", "129868", "10371...
## $ valid_name      &lt;chr&gt; "Metridium senile", "Alloteuthis media", "Aphr...
## $ valid_authority &lt;chr&gt; "(Linnaeus, 1761)", "(Linnaeus, 1758)", "Linna...
## $ kingdom         &lt;chr&gt; "Animalia", "Animalia", "Animalia", "Animalia"...
## $ phylum          &lt;chr&gt; "Cnidaria", "Mollusca", "Annelida", "Annelida"...
## $ class           &lt;chr&gt; "Anthozoa", "Cephalopoda", "Polychaeta", "Poly...
## $ order           &lt;chr&gt; "Actiniaria", "Myopsida", "Phyllodocida", NA, ...
## $ family          &lt;chr&gt; "Actinostolidae", "Loliginidae", "Aphroditidae...
## $ genus           &lt;chr&gt; "Actinoloba", "Alloteuthis", "Aphrodite", "Are...
## $ citation        &lt;chr&gt; "Fautin, D. (2013). Actinoloba dianthus de Bla...
## $ lsid            &lt;chr&gt; "urn:lsid:marinespecies.org:taxname:742385", "...
## $ isMarine        &lt;chr&gt; "1", "1", "1", "1", "1", "1", "1", "1", "1", "...
## $ isBrackish      &lt;chr&gt; NA, NA, "0", "0", NA, "0", NA, NA, "0", NA, NA...
## $ isFreshwater    &lt;chr&gt; NA, NA, "0", "0", "0", "0", NA, "0", "0", NA, ...
## $ isTerrestrial   &lt;chr&gt; NA, NA, "0", "0", "0", "0", NA, "0", "0", NA, ...
## $ isExtinct       &lt;chr&gt; NA, NA, NA, "0", NA, "0", NA, NA, "0", NA, NA,...
## $ match_type      &lt;chr&gt; "exact", "exact", "exact", "exact", "exact", "...
## $ modified        &lt;chr&gt; "2013-10-04T10:33:40Z", "2008-03-12T16:15:40Z"...
</code></pre></div></div>

<p>To check those species for which no Aphia was found, we can set some arguments in <code class="language-plaintext highlighter-rouge">worms_records</code> to do a more exhaustive search. First, identify the species:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">taxa_to_check</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">my_taxa</span><span class="p">[</span><span class="nf">attr</span><span class="p">(</span><span class="n">all_spp_aphia</span><span class="p">,</span><span class="w"> </span><span class="s2">"match"</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"not found"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>First, looks for non-marine matches:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worms_records</span><span class="p">(</span><span class="n">scientific</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taxa_to_check</span><span class="p">,</span><span class="w"> </span><span class="n">marine_only</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## data frame with 0 columns and 0 rows
</code></pre></div></div>
<p>This returns nothing. Then, allow fuzzy (approximate) matching on the names:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worms_records</span><span class="p">(</span><span class="n">scientific</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taxa_to_check</span><span class="p">,</span><span class="w"> </span><span class="n">fuzzy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##               inputid  nil type
## 1   Bidoplax digitata &lt;NA&gt; &lt;NA&gt;
## 2 Chrysaora isosceles &lt;NA&gt; &lt;NA&gt;
## 3     Nerine vulgaris &lt;NA&gt; &lt;NA&gt;
</code></pre></div></div>
<p>This also returns nothing. So we conclude that these names are not present in WoRMS - the reasons why could be the subject of further investigation, referring back to the Sorby collection and cross-checking with other taxonomic authorities and experts.</p>

<p>Add worms_records back into our original dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">all_spp_taxa</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"aphia_id"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"inputid"</span><span class="p">))</span><span class="w">
</span><span class="n">glimpse</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 50
## Variables: 27
## $ taxon_name      &lt;chr&gt; "Actinoloba dianthus", "Alloteuthis media", "A...
## $ aphia_id        &lt;chr&gt; "742385", "153134", "231869", "129868", "10371...
## $ AphiaID         &lt;chr&gt; "742385", "153134", "231869", "129868", "10371...
## $ url             &lt;chr&gt; "http://www.marinespecies.org/aphia.php?p=taxd...
## $ scientificname  &lt;chr&gt; "Actinoloba dianthus", "Alloteuthis media", "A...
## $ authority       &lt;chr&gt; "de Blainville, 1830", "(Linnaeus, 1758)", "(L...
## $ rank            &lt;chr&gt; "Species", "Species", "Species", "Species", "S...
## $ status          &lt;chr&gt; "unaccepted", "accepted", "unaccepted", "accep...
## $ unacceptreason  &lt;chr&gt; NA, NA, "lapsus calami", NA, NA, NA, NA, NA, "...
## $ valid_AphiaID   &lt;chr&gt; "100982", "153134", "129840", "129868", "10371...
## $ valid_name      &lt;chr&gt; "Metridium senile", "Alloteuthis media", "Aphr...
## $ valid_authority &lt;chr&gt; "(Linnaeus, 1761)", "(Linnaeus, 1758)", "Linna...
## $ kingdom         &lt;chr&gt; "Animalia", "Animalia", "Animalia", "Animalia"...
## $ phylum          &lt;chr&gt; "Cnidaria", "Mollusca", "Annelida", "Annelida"...
## $ class           &lt;chr&gt; "Anthozoa", "Cephalopoda", "Polychaeta", "Poly...
## $ order           &lt;chr&gt; "Actiniaria", "Myopsida", "Phyllodocida", NA, ...
## $ family          &lt;chr&gt; "Actinostolidae", "Loliginidae", "Aphroditidae...
## $ genus           &lt;chr&gt; "Actinoloba", "Alloteuthis", "Aphrodite", "Are...
## $ citation        &lt;chr&gt; "Fautin, D. (2013). Actinoloba dianthus de Bla...
## $ lsid            &lt;chr&gt; "urn:lsid:marinespecies.org:taxname:742385", "...
## $ isMarine        &lt;chr&gt; "1", "1", "1", "1", "1", "1", "1", NA, "1", "1...
## $ isBrackish      &lt;chr&gt; NA, NA, "0", "0", NA, "0", NA, NA, NA, "0", NA...
## $ isFreshwater    &lt;chr&gt; NA, NA, "0", "0", "0", "0", NA, NA, "0", "0", ...
## $ isTerrestrial   &lt;chr&gt; NA, NA, "0", "0", "0", "0", NA, NA, "0", "0", ...
## $ isExtinct       &lt;chr&gt; NA, NA, NA, "0", NA, "0", NA, NA, NA, "0", NA,...
## $ match_type      &lt;chr&gt; "exact", "exact", "exact", "exact", "exact", "...
## $ modified        &lt;chr&gt; "2013-10-04T10:33:40Z", "2008-03-12T16:15:40Z"...
</code></pre></div></div>
<p>Now, prior to querying OBIS, we might want to tidy up this dataset. For instance, we could strip out taxa for which we could not find a valid AphiaID or a valid name:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">subset</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">valid_AphiaID</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">valid_name</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>We might also want to restrict further analysis to a particular taxonomic rank. Let’s look at what ranks are present:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">rank</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##   Class  Family   Genus Species 
##       2       1       4      38
</code></pre></div></div>
<p>For now we will work only on species:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">subset</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"Species"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p><strong>NOTE</strong>: taxonomy is difficult, and resolving it tends to be messy, especially when large numbers of names are considered. For instance, the first species in our list is <em>Actinoloba dianthus</em> (ID 742385), which, when run through the process above, returns the ‘accepted’ ID 100982, for <em>Metridium senile</em> (Linnaeus, 1761). However, this <em>in turn</em> is actually unaccepted, and points to a different accepted ID (158251) and name, <em>Metridium dianthus</em> (Ellis, 1768):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worms_records</span><span class="p">(</span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"100982"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   inputid AphiaID
## 1  100982  100982
##                                                             url
## 1 http://www.marinespecies.org/aphia.php?p=taxdetails&amp;id=100982
##     scientificname        authority    rank     status unacceptreason
## 1 Metridium senile (Linnaeus, 1761) Species unaccepted           &lt;NA&gt;
##   valid_AphiaID         valid_name valid_authority  kingdom   phylum
## 1        158251 Metridium dianthus   (Ellis, 1768) Animalia Cnidaria
##      class      order      family     genus
## 1 Anthozoa Actiniaria Metridiidae Metridium
##                                                                                                                                                                                                                                          citation
## 1 Fautin, D. (2015). Metridium senile (Linnaeus, 1761). In: Fautin, Daphne G. (2013). Hexacorallians of the World. Accessed through:  World Register of Marine Species at http://marinespecies.org/aphia.php?p=taxdetails&amp;id=100982 on 2016-09-09
##                                        lsid isMarine isBrackish
## 1 urn:lsid:marinespecies.org:taxname:100982        1       &lt;NA&gt;
##   isFreshwater isTerrestrial isExtinct match_type             modified
## 1         &lt;NA&gt;          &lt;NA&gt;      &lt;NA&gt;      exact 2015-10-13T12:34:41Z
</code></pre></div></div>
<p>To avoid (near)infinite recursion, we have stopped after one round of checking in WoRMS, but users may wish to run the above process more than once, or to randomly check some names in their lists, to ensure that they are confident in their results.</p>

<p>One further modification that may be useful is to add additional taxonomic levels beyond the standard ones returned by <code class="language-plaintext highlighter-rouge">worms_records</code>. For instance, ‘fish’ can be identified as a group using the non-standard Superclass = Pisces. This function simply returns a <code class="language-plaintext highlighter-rouge">TRUE</code>/<code class="language-plaintext highlighter-rouge">FALSE</code> flag telling you whether a given AphiaID belongs to Pisces or not:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_pisces</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">aphiaid</span><span class="p">){</span><span class="w">
  </span><span class="c1"># get hierarchy for a given aphia ID</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">exists</span><span class="p">(</span><span class="s2">"aphia_h"</span><span class="p">)){</span><span class="n">rm</span><span class="p">(</span><span class="n">aphia_h</span><span class="p">)}</span><span class="w">
  </span><span class="n">pisces</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
  </span><span class="n">try</span><span class="p">(</span><span class="n">aphia_h</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">worms_hierarchy</span><span class="p">(</span><span class="n">ids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aphiaid</span><span class="p">),</span><span class="w"> </span><span class="n">silent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">exists</span><span class="p">(</span><span class="s2">"aphia_h"</span><span class="p">)){</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="s2">"Pisces"</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">aphia_h</span><span class="o">$</span><span class="n">scientificname</span><span class="p">){</span><span class="w">
      </span><span class="n">pisces</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">TRUE</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="n">pisces</span><span class="p">)</span><span class="w">	
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Although it takes aphiaid as an input, it can easily be applied to scientific names by running, for instance:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_pisces</span><span class="p">(</span><span class="n">get_wormsid</span><span class="p">(</span><span class="s2">"Gadus morhua"</span><span class="p">,</span><span class="w"> </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] TRUE
</code></pre></div></div>
<p>We can add a pisces column to our dataset like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="o">$</span><span class="n">pisces</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="n">valid_AphiaID</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">valid_AphiaID</span><span class="p">){</span><span class="n">get_pisces</span><span class="p">(</span><span class="n">valid_AphiaID</span><span class="p">)}))</span><span class="w">
</span></code></pre></div></div>
<p>This seems to have produced sensible results:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glimpse</span><span class="p">(</span><span class="n">subset</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">pisces</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 5
## Variables: 28
## $ taxon_name      &lt;chr&gt; "Lipophrys pholis", "Merlangius merlangus", "P...
## $ aphia_id        &lt;chr&gt; "126768", "126438", "127143", "127160", "127387"
## $ AphiaID         &lt;chr&gt; "126768", "126438", "127143", "127160", "127387"
## $ url             &lt;chr&gt; "http://www.marinespecies.org/aphia.php?p=taxd...
## $ scientificname  &lt;chr&gt; "Lipophrys pholis", "Merlangius merlangus", "P...
## $ authority       &lt;chr&gt; "(Linnaeus, 1758)", "(Linnaeus, 1758)", "Linna...
## $ rank            &lt;chr&gt; "Species", "Species", "Species", "Species", "S...
## $ status          &lt;chr&gt; "accepted", "accepted", "accepted", "accepted"...
## $ unacceptreason  &lt;chr&gt; NA, NA, NA, NA, NA
## $ valid_AphiaID   &lt;chr&gt; "126768", "126438", "127143", "127160", "127387"
## $ valid_name      &lt;chr&gt; "Lipophrys pholis", "Merlangius merlangus", "P...
## $ valid_authority &lt;chr&gt; "(Linnaeus, 1758)", "(Linnaeus, 1758)", "Linna...
## $ kingdom         &lt;chr&gt; "Animalia", "Animalia", "Animalia", "Animalia"...
## $ phylum          &lt;chr&gt; "Chordata", "Chordata", "Chordata", "Chordata"...
## $ class           &lt;chr&gt; "Actinopteri", "Actinopteri", "Actinopteri", "...
## $ order           &lt;chr&gt; "Perciformes", "Gadiformes", "Pleuronectiforme...
## $ family          &lt;chr&gt; "Blenniidae", "Gadidae", "Pleuronectidae", "So...
## $ genus           &lt;chr&gt; "Lipophrys", "Merlangius", "Pleuronectes", "So...
## $ citation        &lt;chr&gt; "Bailly, N. (2008). Lipophrys pholis (Linnaeus...
## $ lsid            &lt;chr&gt; "urn:lsid:marinespecies.org:taxname:126768", "...
## $ isMarine        &lt;chr&gt; "1", "1", "1", "1", "1"
## $ isBrackish      &lt;chr&gt; "0", "0", "1", "1", "1"
## $ isFreshwater    &lt;chr&gt; "0", "0", "0", "0", "0"
## $ isTerrestrial   &lt;chr&gt; "0", "0", "0", "0", "0"
## $ isExtinct       &lt;chr&gt; NA, NA, NA, NA, NA
## $ match_type      &lt;chr&gt; "exact", "exact", "exact", "exact", "exact"
## $ modified        &lt;chr&gt; "2008-01-15T18:27:08Z", "2008-01-15T18:27:08Z"...
## $ pisces          &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE
</code></pre></div></div>
<p>We now have a species list with full validated WoRMS records for each, which we can now use to start to query OBIS.</p>

<hr />

<p><a class="anchor" name="gettingoccurrences"></a></p>

<h2 id="getting-occurrences">Getting occurrences</h2>

<p>Once you have your taxon name, or list of names, it is straightforward to extract their OBIS occurrences using the <a href="https://github.com/iobis/robis">robis</a> package. If you are confident that your original list of names is taxonomically correct, free of typos, etc. then you can search directly on them. However, as outlined above, we recommend some basic taxonomic checks which will then allow you to search directly either on AphiaIDs, or on confirmed valid species names. The latter has some benefits in terms of interpreting the output from a search. Once you have obtained a list of occurrences for a given taxon, you can very quickly produce a quick map. You can also obtain occurrences for whole lists of species, with the proviso that the returned data can rapidly become large, especially if all fields are returned (see <strong>Understanding occurrence records</strong>). Here we show how to obtain and map occurrence records for a single species, and then for a list of species.</p>

<p><a class="anchor" name="singlespecies"></a></p>

<h3 id="getting-obis-records-for-a-single-species">Getting OBIS records for a single species</h3>

<p>This is simply achieved using the <code class="language-plaintext highlighter-rouge">robis::occurrence</code> function. Note however that queries can take a while, especially if your species has a very large number of records. The first species in our dataset has a moderate number of records so is a good test case - it takes ~1 minute to run:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">valid_name</span><span class="p">[</span><span class="m">1</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>
<p>This results in a tibble (a dataframe modified to display nicely on screen) with 7,267 rows - one for each record of <em>Metridium senile</em> - and 65 columns. This may seem like a lot of variables, but many of them are useful, as will be explained below. For now, we might want to get some basic summary information, for instance, what are the geographic limits of this set of occurrences? There are various ways to do this, here we will use the bbox function from the <code class="language-plaintext highlighter-rouge">sp</code> package:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bb_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">my_occs</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">my_occs</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
</span><span class="n">bb_occs</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##         min    max
## x -173.5000 145.57
## y  -48.3603  70.60
</code></pre></div></div>
<p>This shows that this species has been recorded very widely, from -173.5 to +145.57 degrees longitude and from -48.36 to +70.60 degrees latitude. We can quickly and roughly plot these data using ggmap functions. For a world map, use data from the maps package:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">world</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_data</span><span class="p">(</span><span class="s2">"world"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This creates a quick and dirty world map - playing around with the themes, aesthetics, and device dimensions is recommended!</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worldmap</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">world</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="n">lat</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_y_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-2</span><span class="o">:</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">30</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_x_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-4</span><span class="o">:</span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">45</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">panel.background</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_rect</span><span class="p">(</span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"steelblue"</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">coord_equal</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>

<p>Now add the occurrence points:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">occ_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_occs</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w">
                                 </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
</span><span class="n">occ_map</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/add occurance points-1.png" style="display: block; margin: auto;" />
You can change the projection using coord_map, for instance:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">occ_map</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">coord_map</span><span class="p">(</span><span class="s2">"ortho"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/change projection-1.png" style="display: block; margin: auto;" /></p>

<p>See <code class="language-plaintext highlighter-rouge">?coord_map</code> for more details. Note that the code above does not treat the latitudes and longitudes obtained from OBIS as true spatial points with an associated projection. For more precise mapping this should be done. Projections are provided for some points, but not for many on this occasion - see:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">my_occs</span><span class="o">$</span><span class="n">geodeticDatum</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## WGS84 
##    10
</code></pre></div></div>

<p>Only 10 of the occurrences have associated projection details (here WGS84) - WGS84 is a sensible default though if you want to project the whole set of occurrences for more formal spatial analysis than we cover here. An alternative mapping approach, which doesn’t work well for global scale maps but can produce nice regional maps, is to get a basemap from google maps, here by feeding it your bounding box:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_map</span><span class="p">(</span><span class="w">
  </span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occs</span><span class="p">,</span><span class="w"> </span><span class="n">maptype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Then add points to this base map like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggmap</span><span class="p">(</span><span class="n">my_map</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_occs</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w">
             </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning: Removed 117 rows containing missing values (geom_point).
</code></pre></div></div>

<p><img src="/images/sorbycollection/googlemap with points-1.png" style="display: block; margin: auto;" /></p>

<p>This will throw a warning about removing 117 rows which do not fit on this map. You can try playing around with the <code class="language-plaintext highlighter-rouge">get_map function</code>, in particular the <code class="language-plaintext highlighter-rouge">zoom</code> argument, to see if you can overcome this but it seems to be a limitation with global scale data (see <a href="http://stackoverflow.com/questions/11201997/world-map-with-ggmap">here</a>) - but the map should work fine if your set of occurrences is less geographically extensive.</p>

<p>There are many options for modifying the map, for instance, you could colour code points by the original scientific name recorded (which OBIS has translated into the accepted name):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_occs</span><span class="p">,</span><span class="w">
                      </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">,</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">originalScientificName</span><span class="p">),</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/modifying maps 1-1.png" style="display: block; margin: auto;" /></p>

<p>Or you could colour code by year collected. First, we can round <code class="language-plaintext highlighter-rouge">yearcollected</code> to give us decade collected:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_occs</span><span class="o">$</span><span class="n">decade</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">my_occs</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="o">*</span><span class="nf">round</span><span class="p">(</span><span class="n">yearcollected</span><span class="o">/</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Then plot like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_occs</span><span class="p">,</span><span class="w">
                      </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">,</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decade</span><span class="p">),</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_colour_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"white"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/modifying maps 3-1.png" style="display: block; margin: auto;" /></p>

<p>The time taken to return occurrences scales with the number of occurrences, so beware that getting global occurrences for well-sampled species will take some time. To take an example from our dataset, the Dover sole <em>Solea solea</em> (Linnaeus, 1758) has a moderately large number of records (64781), which take approximately 2.5 minutes to obtain:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Solea solea"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The returned dataframe is also rather large:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">object_size</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 35.7 MB
</code></pre></div></div>
<p>So, if you anticipate returning large quantities of data from OBIS, it may make sense to limit the fields returned - for instance, you can drastically reduce the size of the data set (and the speed of the query) by returning only the first four fields (ID, lon, lat, and depth):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">object_size</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 1.81 MB
</code></pre></div></div>
<p>In addition, you can pre-filter the occurrences to be returned, e.g. by geographic region, or by other properties of the records, as outlined below.</p>

<p>Nonetheless, you can still easily produce maps with these large numbers of points:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bb_sole</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">SpatialPoints</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">sole_occs</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">)))</span><span class="w">
</span><span class="n">bb_sole</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                min     max
## coords.x1 -42.0288 151.639
## coords.x2 -33.0868  61.250
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_map</span><span class="p">(</span><span class="w">
  </span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_sole</span><span class="p">,</span><span class="w"> </span><span class="n">maptype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="n">sole_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggmap</span><span class="p">(</span><span class="n">sole_map</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w">
             </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot sole records-1.png" style="display: block; margin: auto;" /></p>

<p>Here is a more generic function to produce maps from data returned by <code class="language-plaintext highlighter-rouge">robis::occurrence</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obis_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">map_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"satellite"</span><span class="p">,</span><span class="w"> </span><span class="s2">"world"</span><span class="p">),</span><span class="w"> </span><span class="n">map_zoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">plotit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">){</span><span class="w">
  
  </span><span class="n">bb_occ</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">occ_dat</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">occ_dat</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="n">map_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">){</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">map_zoom</span><span class="p">)){</span><span class="w">
      </span><span class="n">base_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_map</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occ</span><span class="p">,</span><span class="w"> </span><span class="n">maptype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">base_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_map</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occ</span><span class="p">,</span><span class="w"> </span><span class="n">maptype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">,</span><span class="w"> </span><span class="n">zoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_zoom</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="n">obis_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggmap</span><span class="p">(</span><span class="n">base_map</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">map_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"world"</span><span class="p">){</span><span class="w">
    </span><span class="n">base_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_data</span><span class="p">(</span><span class="s2">"world"</span><span class="p">)</span><span class="w">
    </span><span class="n">obis_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">base_map</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="n">lat</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">scale_y_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-2</span><span class="o">:</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">30</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">scale_x_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-4</span><span class="o">:</span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">45</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">theme</span><span class="p">(</span><span class="n">panel.background</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_rect</span><span class="p">(</span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"steelblue"</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">coord_equal</span><span class="p">()</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">stop</span><span class="p">(</span><span class="s2">"map_type must be one of 'satellite' or 'world'"</span><span class="p">,</span><span class="w">
         </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="c1"># Now add the occurrence points</span><span class="w">
  </span><span class="n">obis_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">obis_map</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w">
                                    </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="n">plotit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">T</span><span class="p">){</span><span class="n">print</span><span class="p">(</span><span class="n">obis_map</span><span class="p">)}</span><span class="w">
  
  </span><span class="nf">return</span><span class="p">(</span><span class="n">obis_map</span><span class="p">)</span><span class="w">
  
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Run it like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">obis_map</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="n">map_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/run obis_map-1.png" style="display: block; margin: auto;" /></p>

<p>Create the plot without plotting it:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">obis_map</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="n">map_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">,</span><span class="w"> </span><span class="n">plotit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>If you do not have any prior knowledge about the likely number of OBIS records available for your taxa, and you wish to check before beginning potentially lengthy downloads, you can very rapidly (&lt;0.1 second) get summary data for a given taxon, including the total number of OBIS records, using the taxa function. For sole, you get:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_summ</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">checklist</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Solea solea"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_summ</span><span class="o">$</span><span class="n">records</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 64781
</code></pre></div></div>
<p>So this immediately alerts you to the fact that processing the individual records may be rather slow. You can run this function using scientific name or Aphia ID, and can run it for a list of taxa like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">taxa_summ</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="n">valid_name</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">valid_name</span><span class="p">){</span><span class="n">checklist</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">valid_name</span><span class="p">)}))</span><span class="w">
</span><span class="c1"># equivalently for aphia ID (not run):</span><span class="w">
</span><span class="c1"># taxa_summ &lt;- with(sorby_coll, sapply(valid_AphiaID, function(valid_AphiaID){taxa(aphiaid = valid_AphiaID)}))</span><span class="w">
</span></code></pre></div></div>
<p>Note running the above over a list of taxa returns a list of data frames, one dataframe for each species. Processing these data frames is complicated slightly by the fact that different numbers of variables are returned for different species, depending on the metadata available for that species:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lengths</span><span class="p">(</span><span class="n">taxa_summ</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##     Metridium senile    Alloteuthis media   Aphrodita aculeata 
##                   15                   15                   15 
##     Arenicola marina   Ascidiella aspersa       Aurelia aurita 
##                   14                   16                   15 
## Botryllus schlosseri   Branchiomma bombyx      Carcinus maenas 
##                   15                   15                   16 
##   Ciona intestinalis 
##                   16 
##  [ reached getOption("max.print") -- omitted 28 entries ]
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">lengths</span><span class="p">(</span><span class="n">taxa_summ</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## 14 15 16 17 
##  2 28  4  4
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lapply</span><span class="p">(</span><span class="n">taxa_summ</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $`Metridium senile`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Alloteuthis media`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Aphrodita aculeata`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Arenicola marina`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 4 entries ]
## 
## $`Ascidiella aspersa`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "gisd"      "records"   "datasets" 
##  [ reached getOption("max.print") -- omitted 6 entries ]
## 
## $`Aurelia aurita`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Botryllus schlosseri`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Branchiomma bombyx`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "records"   "datasets"  "phylum"   
##  [ reached getOption("max.print") -- omitted 5 entries ]
## 
## $`Carcinus maenas`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "gisd"      "records"   "datasets" 
##  [ reached getOption("max.print") -- omitted 6 entries ]
## 
## $`Ciona intestinalis`
##  [1] "id"        "valid_id"  "parent_id" "rank_name" "tname"    
##  [6] "tauthor"   "worms_id"  "gisd"      "records"   "datasets" 
##  [ reached getOption("max.print") -- omitted 6 entries ]
## 
##  [ reached getOption("max.print") -- omitted 28 entries ]
</code></pre></div></div>
<p>For our purposes, we just want to extract one variable, ‘records’, the total number of OBIS records for each taxon. There is one further complication that we need to deal with before doing this: checklist will return data for taxonomic children of the taxon queried. For example, from our dataset:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eg_taxon</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">checklist</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Ciona intestinalis"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Returns 3 records, of different taxonomic ranks:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">eg_taxon</span><span class="o">$</span><span class="n">rank_name</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##    Species Subspecies 
##          1          2
</code></pre></div></div>
<p>The simplest option here is to sum the number of OBIS records across all children of each taxon:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obis_n</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="w">
  </span><span class="n">valid_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">taxa_summ</span><span class="p">),</span><span class="w">
  </span><span class="n">obis_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">lapply</span><span class="p">(</span><span class="n">taxa_summ</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">m</span><span class="o">$</span><span class="n">records</span><span class="p">)))</span><span class="w">
</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>This can then be joined back to our master dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorby_coll</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">obis_n</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"valid_name"</span><span class="p">)</span><span class="w">
</span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">valid_name</span><span class="p">,</span><span class="w"> </span><span class="n">obis_n</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## # A tibble: 38 × 2
##              valid_name obis_n
##                   &lt;chr&gt;  &lt;int&gt;
## 1      Metridium senile   7267
## 2     Alloteuthis media    374
## 3    Aphrodita aculeata   5177
## 4      Arenicola marina  13115
## 5    Ascidiella aspersa   5059
## 6        Aurelia aurita   3136
## 7  Botryllus schlosseri   9455
## 8    Branchiomma bombyx    446
## 9       Carcinus maenas  21313
## 10   Ciona intestinalis   5017
## # ... with 28 more rows
</code></pre></div></div>

<p>(Note the need to specify the package from which we want to run the <code class="language-plaintext highlighter-rouge">select</code> function here, as there is a <code class="language-plaintext highlighter-rouge">select</code> function in <code class="language-plaintext highlighter-rouge">raster</code> too. The <code class="language-plaintext highlighter-rouge">package::function</code> format is good practice whenever there might be ambiguity).</p>

<p>Have a look at the distribution of the number of OBIS records across taxa - easier on a log10 scale:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obis_n</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_histogram</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">scale_x_log10</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/record distribution taxa-1.png" style="display: block; margin: auto;" /></p>

<p>For the whole set of species in our list, there are about 1.25M records in OBIS:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sum</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">obis_n</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 1248808
</code></pre></div></div>
<p>We will see below how to get similar summaries by geographic region, both for a pre-defined taxonomic list, and to generate a list for a region directly from OBIS.</p>

<p>First, let’s try running a full OBIS query over our complete list of species. Remember - this is going to return a dataframe with over 1M rows. To keep this more manageable in size, we will restrict the fields returned to the ‘essential’ variables of taxon name, lon and lat, depth, and year. Then get all OBIS records for all species - BE WARNED, this takes ~30 minutes to run:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allspp_obis</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sorby_coll</span><span class="p">,</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="n">valid_name</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">valid_name</span><span class="p">){</span><span class="w">
  </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">valid_name</span><span class="p">,</span><span class="w">
             </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"scientificName"</span><span class="p">,</span><span class="w"> </span><span class="s2">"decimalLongitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"decimalLatitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"depth"</span><span class="p">,</span><span class="w"> </span><span class="s2">"yearcollected"</span><span class="p">))}))</span><span class="w">
</span></code></pre></div></div>
<p>To convert the returned data into a neat dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allspp_obis</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bind_rows</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">as.data.frame</span><span class="p">))</span><span class="w">
</span><span class="n">object_size</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 45 MB
</code></pre></div></div>
<p>This condition should be true:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">identical</span><span class="p">(</span><span class="n">nrow</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">),</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">sorby_coll</span><span class="o">$</span><span class="n">obis_n</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] TRUE
</code></pre></div></div>
<p>You can get some summary info here, such as the range in sample depths, as a histogram:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_histogram</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/summary info obis query-1.png" style="display: block; margin: auto;" /></p>

<p>Or as quartiles:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">quantile</span><span class="p">(</span><span class="n">allspp_obis</span><span class="o">$</span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="o">:</span><span class="m">4</span><span class="o">/</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   0%  25%  50%  75% 100% 
##   -9   28   45   80 3678
</code></pre></div></div>
<p>This can be useful for quickly spotting unusual records - such as extreme depths (max here = 3678m), or possible missing value codes - 23689 records here have a depth value of -9, suggesting this has been used in some datasets as a missing value code:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sum</span><span class="p">(</span><span class="n">allspp_obis</span><span class="o">$</span><span class="n">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">-9</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 23689
</code></pre></div></div>
<p>We will consider how to address this further in the next section.</p>

<p>You might also want to look at number of records by year:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yearcollected</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_freqpoly</span><span class="p">(</span><span class="n">binwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/records per year obis query-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Which you could split by species, either using colour:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yearcollected</span><span class="p">,</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scientificName</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_freqpoly</span><span class="p">(</span><span class="n">binwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"top"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_blank</span><span class="p">())</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/records by year by species obis query-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Or as different facets:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yearcollected</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_freqpoly</span><span class="p">(</span><span class="n">binwidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">facet_wrap</span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">scientificName</span><span class="p">,</span><span class="w"> </span><span class="n">scales</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"free_y"</span><span class="p">)</span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">strip.text.x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">theme</span><span class="p">(</span><span class="n">axis.text.x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_text</span><span class="p">(</span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">90</span><span class="p">,</span><span class="w"> </span><span class="n">hjust</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/facets obis query-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>None of these plots are especially polished, but are intended to give some ideas that can be developed further.</p>

<p>We can plot all of these records on a map (which will take a while to render, with &gt;1.2M points):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allspp_obis</span><span class="p">,</span><span class="w">
                      </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/obis query map-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>It may be preferable in these cases to plot the data on a grid. Here, we create a 5x5 degree global grid:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">global_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">nrows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">180</span><span class="o">/</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">360</span><span class="o">/</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="n">xmn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-180</span><span class="p">,</span><span class="w"> </span><span class="n">xmx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">180</span><span class="p">,</span><span class="w"> </span><span class="n">ymn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-90</span><span class="p">,</span><span class="w"> </span><span class="n">ymx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">90</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<p>Get the longitude and latitude of the OBIS records:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lonlat_sp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allspp_obis</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allspp_obis</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>And sum these over the grid:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gridded_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterize</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lonlat_sp</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_grid</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"count"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>To render these using ggplot, I’ve adapted some code from <a href="https://nrelscience.org/2013/05/30/this-is-how-i-did-it-mapping-in-r-with-ggplot2/">here</a>. First, turn the gridded data back into a dataframe of points, and name the variables sensibly:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obis.p</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">rasterToPoints</span><span class="p">(</span><span class="n">gridded_occs</span><span class="p">))</span><span class="w">
</span><span class="nf">names</span><span class="p">(</span><span class="n">obis.p</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"OBIS"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Then add these using geom_raster to the worldmap generated previously:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_raster</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obis.p</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OBIS</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">scale_fill_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"white"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/add grid to worldmap-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>It may be better to display logged counts:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gridded_obis</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_raster</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obis.p</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log10</span><span class="p">(</span><span class="n">OBIS</span><span class="p">)))</span><span class="w"> </span><span class="o">+</span><span class="w"> 
   </span><span class="n">scale_fill_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"white"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/convert to log counts-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>It is clear from this map that some points are falling on land. You can get a better idea of this by changing the transparency (alpha) value of the fill in the above plot:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">worldmap</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_raster</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obis.p</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log10</span><span class="p">(</span><span class="n">OBIS</span><span class="p">)),</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> 
  </span><span class="n">scale_fill_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"white"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/change alpha value-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>There are various reasons why this may be, ranging from an artifact of the 5-degree binning used, to the level of precision in the location data, to real errors. The next section explains how some additional data from OBIS can be used for initial quality control of returned data.</p>

<hr />

<p><a class="anchor" name="understanding"></a></p>

<h2 id="understanding-occurrence-records">Understanding occurrence records</h2>

<p>As macroecologists, we are typically interested in a relatively small set of variables when returning occurrence data from OBIS. These may reduce to simply taxon name, and the latitude and longitude of each record, perhaps supplemented by the date on which the occurrence was recorded, and the depth of sampling. However, using the methods above with default settings returns by default a dataframe with many columns, often 50 or more (the number varies with taxon). This might seem like overkill, and it may be tempting to restrict the fields that are returned, which can be simply implemented within R in various ways - here we demonstrate how to limit the fields returned from OBIS, and how to select only relevant columns from the returned data. But although this is sometimes going to be sensible (and certainly brings important memory savings when the returned set of occurrences is very large), it is worth understanding these different columns before discarding them. Here we investigate some of the fields returned, and show how to filter your results based on values of any of these, individually or in combination.</p>

<p><a class="anchor" name="examining"></a></p>

<h3 id="examining-obis-records-in-more-detail">Examining OBIS records in more detail</h3>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glimpse</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Observations: 64,781
## Variables: 54
## $ id                            &lt;int&gt; 343136975, 345256421, 345256359,...
## $ decimalLongitude              &lt;dbl&gt; -8.6240000, 6.4970000, 3.7851667...
## $ decimalLatitude               &lt;dbl&gt; 54.61800, 54.79467, 52.47767, 50...
## $ depth                         &lt;dbl&gt; 32, 40, 25, 30, 36, 25, 26, 37, ...
## $ basisOfRecord                 &lt;chr&gt; "Occurrence", "Occurrence", "Occ...
## $ eventDate                     &lt;chr&gt; "1996-07-16 10:00:00", "1993-10-...
## $ institutionCode               &lt;chr&gt; "EcoServe", "CEFAS", "CEFAS", "C...
## $ collectionCode                &lt;chr&gt; "BioMar", "BenticNSECCS", "Benti...
## $ catalogNumber                 &lt;chr&gt; "9290", "240", "800", "1305", "2...
## $ locality                      &lt;chr&gt; "Mouth of Teelin Harbour, N Done...
## $ datasetName                   &lt;chr&gt; "BioMar - Ireland: benthic marin...
## $ phylum                        &lt;chr&gt; "Chordata", "Chordata", "Chordat...
## $ order                         &lt;chr&gt; "Pleuronectiformes", "Pleuronect...
## $ family                        &lt;chr&gt; "Soleidae", "Soleidae", "Soleida...
## $ genus                         &lt;chr&gt; "Solea", "Solea", "Solea", "Sole...
## $ scientificName                &lt;chr&gt; "Solea solea", "Solea solea", "S...
## $ originalScientificName        &lt;chr&gt; "Solea solea", "Solea solea", "S...
## $ scientificNameAuthorship      &lt;chr&gt; "(Linnaeus, 1758)", "(Linnaeus, ...
## $ obisID                        &lt;int&gt; 511164, 511164, 511164, 511164, ...
## $ resourceID                    &lt;int&gt; 47, 51, 51, 51, 51, 51, 51, 51, ...
## $ yearcollected                 &lt;int&gt; 1996, 1993, 1992, 1992, 1994, 19...
## $ species                       &lt;chr&gt; "Solea solea", "Solea solea", "S...
## $ qc                            &lt;int&gt; 1073215583, 1073183871, 10731838...
## $ aphiaID                       &lt;int&gt; 127160, 127160, 127160, 127160, ...
## $ speciesID                     &lt;int&gt; 511164, 511164, 511164, 511164, ...
## $ minimumDepthInMeters          &lt;dbl&gt; 31.3, 40.0, 25.0, 30.0, 36.0, 25...
## $ maximumDepthInMeters          &lt;dbl&gt; 32.7, 40.0, 25.0, 30.0, 36.0, 25...
## $ county                        &lt;chr&gt; "Donegal", NA, NA, NA, NA, NA, N...
## $ datasetID                     &lt;chr&gt; "IMIS:dasid:345", "IMIS:dasid:50...
## $ fieldNumber                   &lt;chr&gt; "12", "E16", "E32", "S40", "W66"...
## $ modified                      &lt;chr&gt; "2005-12-15 11:42:26", "2005-04-...
## $ occurrenceID                  &lt;chr&gt; "urn:catalog:EcoServe:BioMar:929...
## $ recordedBy                    &lt;chr&gt; "BioMar team", NA, NA, NA, NA, N...
## $ references                    &lt;chr&gt; "http://www.habitas.org.uk/marin...
## $ scientificNameID              &lt;chr&gt; "urn:lsid:marinespecies.org:taxn...
## $ class                         &lt;chr&gt; "Actinopteri", "Actinopteri", "A...
## $ individualCount               &lt;dbl&gt; NA, 2, 1, 1, 1, 1, 1, 1, 3, 1, 3...
## $ occurrenceRemarks             &lt;chr&gt; NA, "Sampling gear:2-m beam traw...
## $ specificEpithet               &lt;chr&gt; NA, "solea", "solea", "solea", "...
## $ identifiedBy                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ continent                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ coordinateUncertaintyInMeters &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ otherCatalogNumbers           &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ recordNumber                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ sex                           &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ bibliographicCitation         &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ stateProvince                 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ dynamicProperties             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ eventTime                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ dateIdentified                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ footprintWKT                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ lifestage                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ eventID                       &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
## $ waterBody                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, ...
</code></pre></div></div>
<p>This reveals that sole_occs has 54 variables. Not all of them complete - get an idea of the proportion of records with data for each field using:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">round</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="n">apply</span><span class="p">(</span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">),</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">mean</span><span class="p">)),</span><span class="w"> </span><span class="m">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                     waterBody                        county 
##                         0.000                         0.000 
##                dateIdentified                    references 
##                         0.000                         0.001 
##                     lifestage                       eventID 
##                         0.003                         0.003 
##                  footprintWKT          minimumDepthInMeters 
##                         0.003                         0.006 
##           otherCatalogNumbers                  identifiedBy 
##                         0.009                         0.009 
##                  recordNumber                 stateProvince 
##                         0.009                         0.014 
##                   fieldNumber                     continent 
##                         0.014                         0.027 
##                      locality             dynamicProperties 
##                         0.049                         0.396 
##                     eventTime             occurrenceRemarks 
##                         0.905                         0.945 
##                           sex               individualCount 
##                         0.945                         0.947 
## coordinateUncertaintyInMeters          maximumDepthInMeters 
##                         0.952                         0.954 
##                         depth               specificEpithet 
##                         0.955                         0.958 
##         bibliographicCitation                    recordedBy 
##                         0.964                         0.970 
##                     datasetID                      modified 
##                         0.998                         0.998 
##                 basisOfRecord                  occurrenceID 
##                         0.998                         0.998 
##                     eventDate                 yearcollected 
##                         0.998                         0.998 
##               institutionCode                collectionCode 
##                         1.000                         1.000 
##                 catalogNumber                            id 
##                         1.000                         1.000 
##              decimalLongitude               decimalLatitude 
##                         1.000                         1.000 
##                   datasetName                        phylum 
##                         1.000                         1.000 
##                         order                        family 
##                         1.000                         1.000 
##                         genus                scientificName 
##                         1.000                         1.000 
##        originalScientificName      scientificNameAuthorship 
##                         1.000                         1.000 
##                        obisID                    resourceID 
##                         1.000                         1.000 
##                       species                            qc 
##                         1.000                         1.000 
##                       aphiaID                     speciesID 
##                         1.000                         1.000 
##              scientificNameID                         class 
##                         1.000                         1.000
</code></pre></div></div>
<p>The key variables we are usually interested in, as noted above, are longitude (<code class="language-plaintext highlighter-rouge">decimalLongitude</code>) and latitude (<code class="language-plaintext highlighter-rouge">decimalLatitude</code>), which - together with taxonomic information and information on the dataset from which observation records come - should be available for all records. Often we like to know sample depth (<code class="language-plaintext highlighter-rouge">depth</code>) too (here available for ~95% of observations), and some information on the date of sampling - this is recorded as <code class="language-plaintext highlighter-rouge">eventDate</code>, in <code class="language-plaintext highlighter-rouge">YYYY-MM-DD HH:MM:SS</code> format, with some useful simplified date fields too, such as <code class="language-plaintext highlighter-rouge">yearcollected</code>, usually available for most records (here, &gt;99%). Some records have abundance data (<code class="language-plaintext highlighter-rouge">individualCount</code>) - almost 95% of those in this dataset, which includes lots of data from fisheries surveys (which typically count abundance) - the proportion is likely to be much lower for many invertebrate taxa. <code class="language-plaintext highlighter-rouge">originalScientificName</code> gives the scientific name used by the person or organisation who recorded the observation. This can be compared to <code class="language-plaintext highlighter-rouge">scientificName</code>, which is the valid name used in OBIS. Here, OBIS has aggregated records from both <em>Solea solea</em> and the unaccepted name <em>Solea vulgaris</em>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">originalScientificName</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##    Solea solea Solea vulgaris 
##           6561          58220
</code></pre></div></div>
<p>Supplying the original as well as the accepted name makes it possible to analyse occurrences separately if required. <code class="language-plaintext highlighter-rouge">coordinateUncertaintyInMeters</code> gives the precision of the location information. It is stored as a character, but we can look numeric values:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">coordinateUncertaintyInMeters</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##       0    70.7     100 101.029 102.326 104.697 107.937 110.592     111 
##   60549     172      19       1       1       1       1       1     328 
## 112.951 113.574 116.289  118.95 121.649 121.847 125.962 135.726 137.837 
##       1       1       1       1       1       1       1       1       1 
## 138.153 142.822  143.76 144.123 154.993    1000    2804    3769    5000 
##       1       1       1       1       1       8       1       1     564 
##   10000   19310   23616   26188   58302  294046  759510  880229 
##       5       1       2       5       1       1       1       1
</code></pre></div></div>
<p>Note that uncertainty varies greatly from 0m to 880km - highest uncertainty often arises when only a country or ocean basin has been recorded. This information could be useful in excluding certain imprecise occurrence records, for instance.</p>

<p>It is also possible to filter based on a series of Quality Control flags, as defined by <a href="http://doi.org/10.1093/database/bau125">Vandepitte et al. (2015)</a>. You can get brief definitions of the flags by typing:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span><span class="n">qc</span><span class="w">
</span></code></pre></div></div>
<p>These flags are stored for each record as integers in the variable <code class="language-plaintext highlighter-rouge">qc</code>, each of which represent a bit sequence. So:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs</span><span class="o">$</span><span class="n">qc</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 1073215583
</code></pre></div></div>
<p>Corresponds to the bit sequence:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">intToBits</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">qc</span><span class="p">[</span><span class="m">1</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1] 01 01 01 01 01 00 01 00 00 00 00 01 01 01 01 01 01 01 01 00 01 01 01
## [24] 01 01 01 01 01 01 01 00 00
</code></pre></div></div>
<p>Or alternatively, to see which flags are ‘on’ (i.e. QC indicates a valid record based on that flag):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">as.logical</span><span class="p">(</span><span class="n">intToBits</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">qc</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE
## [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
## [23]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE
</code></pre></div></div>
<p>Note that flags 8, 9, and 20 are currently disabled and will always be off/<code class="language-plaintext highlighter-rouge">FALSE</code>. Note too that <code class="language-plaintext highlighter-rouge">intToBits</code> converts the integer into 32 values as R integers are 32 bit. The final 2 values are therefore not relevant to QC flags, of which there are only 30, and will always be <code class="language-plaintext highlighter-rouge">FALSE</code>.</p>

<p>Using these flags to filter a dataframe is relatively straightforward, implemented in the following function which takes an occurrence dataset (which should have a <code class="language-plaintext highlighter-rouge">qc</code> variable, assumed to be named “qc” although you can specify an alternative) and a vector of qc flags that you wish to filter on - i.e. records in which any one of these flags is off (<code class="language-plaintext highlighter-rouge">FALSE</code>) will be stripped from the result:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter_by_qc_flags</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">qc_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"qc"</span><span class="p">,</span><span class="w"> </span><span class="n">qc_flags</span><span class="p">){</span><span class="w">
  
  </span><span class="n">get_allon_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">qc_var</span><span class="p">,</span><span class="w"> </span><span class="n">qc_flags</span><span class="p">){</span><span class="w">
    
    </span><span class="n">mask</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">2</span><span class="o">^</span><span class="p">(</span><span class="n">qc_flags</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
    </span><span class="n">qc_flags_on</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="n">qc_var</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="nf">sum</span><span class="p">(</span><span class="n">bitwAnd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)})</span><span class="w">
    </span><span class="n">all_on</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">qc_flags_on</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">qc_flags</span><span class="p">))</span><span class="w">
    </span><span class="n">all_on</span><span class="w">	
  </span><span class="p">}</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">qc_flags</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">qc_flags</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">30</span><span class="w"> </span><span class="o">|</span><span class="w">
     </span><span class="o">!</span><span class="p">(</span><span class="nf">class</span><span class="p">(</span><span class="n">qc_flags</span><span class="p">)</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"numeric"</span><span class="p">,</span><span class="w"> </span><span class="s2">"integer"</span><span class="p">))){</span><span class="w">
    </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Invalid values for qc_flags, must be integers in the range 1:30"</span><span class="p">,</span><span class="w">
         </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  
  </span><span class="k">if</span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">20</span><span class="p">)</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">qc_flags</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">){</span><span class="w">
    </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Flags 8, 9 and 20 are currently disabled and no records would be returned by your query"</span><span class="p">,</span><span class="w">
         </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="n">qc_var</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">"qc"</span><span class="p">){</span><span class="n">occ_dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plyr</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'qc'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">qc_var</span><span class="p">)))}</span><span class="w">
  </span><span class="n">id_all_on</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_allon_ids</span><span class="p">(</span><span class="n">occ_dat</span><span class="o">$</span><span class="n">qc</span><span class="p">,</span><span class="w"> </span><span class="n">qc_flags</span><span class="p">)</span><span class="w">
  
  </span><span class="n">occ_dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occ_dat</span><span class="p">[</span><span class="n">id_all_on</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="n">qc_var</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">"qc"</span><span class="p">){</span><span class="n">occ_dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plyr</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="n">eval</span><span class="p">(</span><span class="n">qc_var</span><span class="p">),</span><span class="w"> </span><span class="s1">'qc'</span><span class="p">))}</span><span class="w">
  
  </span><span class="nf">return</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">)</span><span class="w">
  
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>You run the function like this - for instance to filter to all records meeting QC flags <code class="language-plaintext highlighter-rouge">1:7</code> and <code class="language-plaintext highlighter-rouge">11:15</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_qc_filt</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">filter_by_qc_flags</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="n">qc_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">15</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>This has filtered out 2249 records:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nrow</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">sole_qc_filt</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 2249
</code></pre></div></div>
<p>Other variables you might wish to filter on include depth, where numeric values are occasionally used to indicate null values. In particular, some data providers have used -9 as a null value for depth, which is hard to spot as it is feasible as a value (e.g. in the high intertidal zone). We can check for this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sum</span><span class="p">(</span><span class="n">sole_occs</span><span class="o">$</span><span class="n">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">-9</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 2204
</code></pre></div></div>
<p>Check which datasets these come from:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dodgy_depths</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> 	</span><span class="n">with</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="n">tapply</span><span class="p">(</span><span class="n">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">-9</span><span class="p">,</span><span class="w"> </span><span class="n">datasetName</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">))</span><span class="w">
</span><span class="n">dodgy_depths</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">dataset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">dodgy_depths</span><span class="p">),</span><span class="w"> </span><span class="n">n_depths</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.vector</span><span class="p">(</span><span class="n">dodgy_depths</span><span class="p">))</span><span class="w">
</span><span class="n">subset</span><span class="p">(</span><span class="n">dodgy_depths</span><span class="p">,</span><span class="w"> </span><span class="n">n_depths</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                                                                          dataset
## 25            ICES Baltic International Trawl Survey for commercial fish species
## 26                            ICES Beam Trawl Survey for commercial fish species
## 29 ICES French Southern Atlantic Bottom Trawl Survey for commercial fish species
## 30  ICES North Sea International Bottom Trawl Survey for commercial fish species
##    n_depths
## 25       25
## 26     2094
## 29        2
## 30       83
</code></pre></div></div>
<p>All of these datasets are ICES trawl surveys - meta data for these could be checked in detail to confirm whether -9 has been used as a missing value for depth.</p>

<p>You can filter your data by any number of conditions to derive a dataset that you are happy to work with, for instance here we restrict the data to observations which include sample depth, year collected, individual counts (i.e. abundance), and where depth is not -9 (which we think is a poorly-chosen null value - see above):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="w">
  </span><span class="n">sole_occs</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">yearcollected</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">individualCount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">-9</span><span class="p">)</span><span class="w">
</span><span class="n">nrow</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 58724
</code></pre></div></div>
<p>This has stripped out 6057 observations:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nrow</span><span class="p">(</span><span class="n">sole_occs</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 6057
</code></pre></div></div>
<p>Of course you can also filter by any other field, for instance returning only data from specific datasets (<code class="language-plaintext highlighter-rouge">datasetName</code>), collected by a specific institute (<code class="language-plaintext highlighter-rouge">institutionCode</code>), etc.</p>

<p>If you know in advance which fields you want to work on, you can select these at the search stage. <code class="language-plaintext highlighter-rouge">robis::occurrence</code> also provides the option of specifying certain QC flags to be on, and setting a <code class="language-plaintext highlighter-rouge">startdate</code>, <code class="language-plaintext highlighter-rouge">enddate</code>, or both, so that you can return records collected within a specified date range. For instance, here, we require qc flags <code class="language-plaintext highlighter-rouge">1:7</code> and <code class="language-plaintext highlighter-rouge">19</code> to be on, return only certain fields, and only records collected since 2010:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_new</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="s2">"Solea solea"</span><span class="p">,</span><span class="w">
                            </span><span class="n">fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"decimalLongitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"decimalLatitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"yearcollected"</span><span class="p">,</span><span class="w"> </span><span class="s2">"depth"</span><span class="p">,</span><span class="w"> </span><span class="s2">"qc"</span><span class="p">),</span><span class="w">
                            </span><span class="n">startdate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"2010-01-01"</span><span class="p">),</span><span class="w"> </span><span class="n">qc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">19</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The final filtering you can do at this querying stage is by geometry - i.e., to return records only from a specified geographical area. We will cover this later on.</p>

<hr />

<p><a class="anchor" name="enriching"></a></p>

<h2 id="enriching-obis-data">Enriching OBIS data</h2>

<p>Now that you have obtained global OBIS records for your taxon or taxa of interest, and are confident that you understand them, there are a number of ways in which you may wish to enrich them. We provide examples here of enriching with environmental data, including examples of layers that require matching only in space (bathymetry) and those that can be matched in space and time (SST). These examples import openly available environmental data on the fly; we also provide examples of matching OBIS records to local copies of environmental data in various formats.</p>

<p><a class="anchor" name="sampledepths"></a></p>

<h3 id="matching-sample-depths-to-bathymetry">Matching sample depths to bathymetry</h3>

<p>In 2010 we published a <a href="http://dx.doi.org/10.1371/journal.pone.0010223">paper</a> showing how records in OBIS were distributed throughout the water column. We did this by matching the sample depth recorded in OBIS to a global bathymetry (<a href="https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/docs/ETOPO1.pdf">ETOPO1</a>). The resulting figure, showing the gap in sampling in the deep pelagic ocean, was used widely during the publication of the <a href="http://www.coml.org/">Census of Marine Life</a>. We <a href="http://shefmeme.org/mola_mola/the-big-blue-bit-in-the-middle-still-big-still-blue/">updated this figure in 2013</a>, adding a further 12M records, which closed this gap to some extent. Both of these analyses were performed using offline matching of OBIS data to bathymetric data. Here we show how the R packages <a href="https://github.com/iobis/robis">robis</a> and <a href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0073051">marmap (Pante &amp; Simon-Bouhet 2013)</a> can be combined to perform similar operations live within R.</p>

<p>Here we use the <code class="language-plaintext highlighter-rouge">marmap</code> package (<a href="http://dx.doi.org/10.1371/journal.pone.0073051">Pante &amp; Simon-Bouchet 2013</a>) to obtain bathymetry from ETOPO1 data and match it to our refined sole occurrence data. First, we need to get a bounding box for our occurrence data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bb_sole</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">SpatialPoints</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>
<p>Now we can directly query the ETOPO1 bathymetry database for this region. We need to decide on a suitable spatial resolution - the finer the resolution, the larger and slower the download. The default is 4 arc minutes, the finest resolution is 1 arc minute (approx 1.852km, depending on location) so you need to bear this in mind: sample depths greater than bottom depths are possible because bottom depth is averaged over ~4km^2, and bottom depths &gt;0m are possible when the grid cell includes both land and sea.
This download takes around 8 minutes - if you plan to do lots of work with bathymetry it would be more efficient to first get an overall bounding box for all species (say) that you wish to query, so you only need run one query. Alternatively you download either the entire <a href="https://www.ngdc.noaa.gov/mgg/global/global.html">global dataset</a> or some <a href="https://www.ngdc.noaa.gov/mgg/geodas/geodas.html">selection of it</a> to store locally and then read into R (see examples of this kind of procedure below).</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_bathy</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">getNOAA.bathy</span><span class="p">(</span><span class="w">
  </span><span class="n">lon1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_sole</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lon2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_sole</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
  </span><span class="n">lat1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_sole</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lat2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_sole</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
  </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">antimeridian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Other parameters set here are <code class="language-plaintext highlighter-rouge">keep = T</code>, which keeps a local copy of this download to avoid having to download again if the exact same query is run, and <code class="language-plaintext highlighter-rouge">antimeridian = F</code>, which specifies how the query is wrapped around the 180th meridian: for a given pair of longitude values, e.g. -150 (150 degrees West) and 150 (degrees East), you have the possibility to get data for 2 distinct regions: the area centered on the antimeridian (60 degrees wide, when <code class="language-plaintext highlighter-rouge">antimeridian = TRUE</code>) or the area centered on the prime meridian (300 degrees wide, when <code class="language-plaintext highlighter-rouge">antimeridian=FALSE</code>). It is recommended to use <code class="language-plaintext highlighter-rouge">keep = TRUE</code> in combination with <code class="language-plaintext highlighter-rouge">antimeridian = TRUE</code> since gathering data for an area around the antimeridian requires two distinct queries to NOAA servers. For this query, we are interested in a region a long way from the antimeridian so can safely set it to <code class="language-plaintext highlighter-rouge">FALSE</code>.</p>

<p><code class="language-plaintext highlighter-rouge">marmap</code> provides a number of useful functions for producing nice plots of bathymetry (see <a href="http://dx.doi.org/10.1371/journal.pone.0073051">Pante &amp; Simon-Bouchet 2013</a>), but for our purposes it is easier to deal with the data in raster format, so we will convert it here:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_bathy_r</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">marmap</span><span class="o">::</span><span class="n">as.raster</span><span class="p">(</span><span class="n">sole_bathy</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>You can now extract values from this bathymetry layer for a given point, for instance, for our first sole occurrence:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">extract</span><span class="p">(</span><span class="n">sole_bathy_r</span><span class="p">,</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">)[</span><span class="m">1</span><span class="p">,])</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##     
## -40
</code></pre></div></div>
<p>For all sole occurrences:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="w">
  </span><span class="n">sole_bathy_r</span><span class="p">,</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Note that values returned from ETOPO1 are negative for depths (and positive for altitudes above sea level), whereas our sample depths are positive (larger number = deeper depth). If we want to compare sample depth to bottom depth we need to fix this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">-</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w">
</span></code></pre></div></div>
<p>We can now plot sample depth against bottom depth, here showing too the 1:1 line, and a vertical line at bottom depth = 0:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bottom_depth</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"steelblue"</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_abline</span><span class="p">(</span><span class="n">slope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">intercept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_vline</span><span class="p">(</span><span class="n">xintercept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot sample depth against bottom depth-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>This plot illustrates some of the issues with using an estimate of bottom depth that, while fine resolution (1 minute) for a global dataset, fails to capture small-scale topographic variation resulting in many sample depths being apparently deeper than the bottom depth. This issue is particularly pronounced around coasts, and users may wish to find either a finer scale bathymetric dataset for their region of interest, or else deal with these coastal areas in some other way (e.g. setting all positive values from ETOPO1 to 0, NA, or similar).</p>

<p>It may be useful however to contrast the results for sole (a demersal flatfish) with a known pelagic species from our dataset, such as the moon jelly <em>Aurelia aurita</em>. First, get occurrences:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jelly_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Aurelia aurita"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Filter to retain records with valid depths:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jelly_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="w">
  </span><span class="n">jelly_occs</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">-9</span><span class="p">)</span><span class="w">
</span><span class="n">nrow</span><span class="p">(</span><span class="n">jelly_occs</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 1897
</code></pre></div></div>
<p>These records come from all over the world, so obtaining the bathymetry data will take a long time:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bb_jelly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">SpatialPoints</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">jelly_occs</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">jelly_occs</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>However, there are a good number of records within the region queried for sole, so we can just consider those for now:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jelly_occs</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="w">
  </span><span class="n">sole_bathy_r</span><span class="p">,</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">jelly_occs</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
</span><span class="n">jelly_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">jelly_occs</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">bottom_depth</span><span class="p">))</span><span class="w">
</span><span class="n">jelly_occs</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">-</span><span class="n">jelly_occs</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w">
</span></code></pre></div></div>

<p>Now combine this with the sole data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_jelly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rbind</span><span class="p">(</span><span class="w">
  </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">scientificName</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">bottom_depth</span><span class="p">),</span><span class="w">
  </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">jelly_occs</span><span class="p">,</span><span class="w"> </span><span class="n">scientificName</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">bottom_depth</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="n">sole_v_jelly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">sole_jelly</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bottom_depth</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scientificName</span><span class="p">),</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_smooth</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scientificName</span><span class="p">),</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"lm"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_colour_manual</span><span class="p">(</span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"darkorange"</span><span class="p">,</span><span class="w"> </span><span class="s2">"steelblue"</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_abline</span><span class="p">(</span><span class="n">slope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">intercept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_vline</span><span class="p">(</span><span class="n">xintercept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/combine jelly and sole-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Despite the issues with bottom depth resolution then, this plot nicely shows the contrast between a demersal fish and a pelagic jelly.</p>

<p>This function is a more general implementation of the above code:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">bathy_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">bathy_keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">bathy_antimerid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">){</span><span class="w">
  
  </span><span class="c1"># occ_dat is assumed to be a dataframe as returned from robis::occurrence, including as a minimum the fields:</span><span class="w">
  </span><span class="c1"># decimalLongitude, decimalLatitude, depth</span><span class="w">
  </span><span class="c1"># Other arguments are passed to marmap. The default resolution is 10 minutes,</span><span class="w">
  </span><span class="c1"># defaults for keep and antimeridion are T and F respectively</span><span class="w">
  
  </span><span class="c1"># This gets the bathymetry and converts it to a raster</span><span class="w">
  </span><span class="n">bb_occs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">occ_dat</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">occ_dat</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
  </span><span class="n">occs_bathy</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">marmap</span><span class="o">::</span><span class="n">as.raster</span><span class="p">(</span><span class="w">
    </span><span class="n">getNOAA.bathy</span><span class="p">(</span><span class="w">
      </span><span class="n">lon1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occs</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lon2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occs</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
      </span><span class="n">lat1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occs</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lat2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bb_occs</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
      </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bathy_res</span><span class="p">,</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bathy_keep</span><span class="p">,</span><span class="w"> </span><span class="n">antimeridian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bathy_antimerid</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
  
  </span><span class="c1"># This creates the bottom_depth variable in occ dat</span><span class="w">
  </span><span class="n">occ_dat</span><span class="o">$</span><span class="n">bottom_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">-</span><span class="n">extract</span><span class="p">(</span><span class="w">
    </span><span class="n">occs_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">
  
  </span><span class="c1"># record the bathymetry resolution used as an attribute of occ_dat</span><span class="w">
  </span><span class="nf">attr</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="s2">"bathymetry_res"</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bathy_res</span><span class="w">
  
  </span><span class="c1"># return the occ_dat dataframe with bottom depth added</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="n">occ_dat</span><span class="p">)</span><span class="w">
  
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Quick test on sole data, leaving resolution at 10 minutes for speed:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bathy_test</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_bottom_depth</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><a class="anchor" name="temperature"></a></p>

<h3 id="matching-occurrences-to-temperature-in-space-and-time">Matching occurrences to temperature in space and time</h3>

<p>Matching species occurrences to environmental variables is a very common requirement of macroecological analyses, particularly those considering environmental drivers of species distributions, and how distributions are expected to shift as the climate changes. There are now numerous freely available environmental data layers which differ in the methods employed to generate them, as well as their spatial and temporal resolution. Here we show how to obtain <a href="http://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.html">NOAA gridded monthly mean Sea Surface Temperature</a> data and to match occurrence records to temperature in both space and time.</p>

<p>This code is from a package in development with ROpenSci called <code class="language-plaintext highlighter-rouge">spenv</code>, see <a href="https://github.com/ropenscilabs/spenv">here</a>.</p>

<p>We’ll use slightly modified versions of <code class="language-plaintext highlighter-rouge">spenv</code> functions here. First, this function downloads SST data from NOAA. Specifically, it downloads monthly mean data at 1 degree resolution from the Optimum Interpolation Seas Surface Temperature V2 dataset, see <a href="http://www.esrl.noaa.gov/psd/data/gridded/data.noaa.oisst.v2.html">here</a>. The data are served as a NetCDF file, but for convenience we transform this into a raster brick - this is essentially a stacked set of global rasters, each layer representing a single month in the time series. The first time you run this the file will be downloaded (takes ~10 seconds). It will then be stored locally for future use:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sst_prep</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"~/.spenv/noaa_sst"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">file.path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="s2">"sst.mnmean.nc"</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file.exists</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">dir.create</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">recursive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">showWarnings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
    </span><span class="n">download.file</span><span class="p">(</span><span class="s2">"ftp://ftp.cdc.noaa.gov/Datasets/noaa.oisst.v2/sst.mnmean.nc"</span><span class="p">,</span><span class="w"> </span><span class="n">destfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">raster</span><span class="o">::</span><span class="n">brick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">varname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sst"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>So, to get the SST data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sst_dat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sst_prep</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>View the structure of the data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sst_dat</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : RasterBrick 
## dimensions  : 180, 360, 64800, 417  (nrow, ncol, ncell, nlayers)
## resolution  : 1, 1  (x, y)
## extent      : 0, 360, -90, 90  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 
## data source : /Users/alunjones/.spenv/noaa_sst/sst.mnmean.nc 
## names       : X1981.12.01, X1982.01.01, X1982.02.01, X1982.03.01, X1982.04.01, X1982.05.01, X1982.06.01, X1982.07.01, X1982.08.01, X1982.09.01, X1982.10.01, X1982.11.01, X1982.12.01, X1983.01.01, X1983.02.01, ... 
## Date        : 1981-12-01, 2016-08-01 (min, max)
## varname     : sst
</code></pre></div></div>
<p>You can plot a few months too:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">sst_dat</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot sstdata-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>You don’t need to run the above code as it is automatically called from the following functions, but it gives you an idea of the structure of the environmental data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">dim</span><span class="p">(</span><span class="n">sst_dat</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 180 360 417
</code></pre></div></div>
<p>180 degrees latitude x 360 degrees longitude x 416 months.</p>

<p>This is the wrapper function that takes your input data (x), together with identifiers for latitude, longitude, and date, and gets SST data from the NOAA SST gridded dataset. The origin argument enables conversion between the date formats of the NOAA data and your occurrence data. Note that this data also calculates an adjusted longitude, as occupancy data typically come with longitude in the range -180 (180 West) to +180 (180 East), whereas the NOAA data codes longitude as 0 to 360 degrees (running eastwards from 0 degrees):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sp_extract_gridded_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"noaa_sst"</span><span class="p">,</span><span class="w"> </span><span class="n">latitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w">
                                    </span><span class="n">longitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"1800-1-1"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
  
  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">spenv_guess_latlondate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="p">)</span><span class="w">
  </span><span class="nf">switch</span><span class="p">(</span><span class="n">from</span><span class="p">,</span><span class="w">
         </span><span class="n">noaa_sst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
           </span><span class="n">mb</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sst_prep</span><span class="p">()</span><span class="w">
           </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">()</span><span class="w">
           </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">x</span><span class="o">$</span><span class="n">date</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">
           </span><span class="n">x</span><span class="o">$</span><span class="n">date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="n">x</span><span class="o">$</span><span class="n">date</span><span class="p">)</span><span class="w">
           </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">$</span><span class="n">date</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">mb</span><span class="o">@</span><span class="n">z</span><span class="p">[[</span><span class="s2">"Date"</span><span class="p">]]),</span><span class="w"> </span><span class="p">]</span><span class="w">
           </span><span class="n">x</span><span class="o">$</span><span class="n">lon_adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="o">$</span><span class="n">longitude</span><span class="w">
           </span><span class="n">x</span><span class="o">$</span><span class="n">lon_adj</span><span class="p">[</span><span class="n">x</span><span class="o">$</span><span class="n">lon_adj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="o">$</span><span class="n">lon_adj</span><span class="p">[</span><span class="n">x</span><span class="o">$</span><span class="n">lon_adj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">360</span><span class="w">
           </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nf">seq_len</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
             </span><span class="n">out</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">get_env_par_space_x_time</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="p">)</span><span class="w">
           </span><span class="p">}</span><span class="w">
           </span><span class="n">x</span><span class="o">$</span><span class="n">sst</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">unlist</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w">
           </span><span class="n">x</span><span class="w">
         </span><span class="p">}</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>The following functions are utility functions called by the above function.
This takes an occurrence dataset and ensures that latitude, longitude, and date variables are correctly identified and named:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spenv_guess_latlondate</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">lat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">xnames</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nf">is.null</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">lats</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xnames</span><span class="p">[</span><span class="n">grep</span><span class="p">(</span><span class="s2">"^(lat|latitude)$"</span><span class="p">,</span><span class="w"> </span><span class="n">xnames</span><span class="p">,</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)]</span><span class="w">
    </span><span class="n">lngs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xnames</span><span class="p">[</span><span class="n">grep</span><span class="p">(</span><span class="s2">"^(lon|lng|long|longitude)$"</span><span class="p">,</span><span class="w"> </span><span class="n">xnames</span><span class="p">,</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)]</span><span class="w">
    
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">lngs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">message</span><span class="p">(</span><span class="s2">"Assuming '"</span><span class="p">,</span><span class="w"> </span><span class="n">lngs</span><span class="p">,</span><span class="w"> </span><span class="s2">"' and '"</span><span class="p">,</span><span class="w"> </span><span class="n">lats</span><span class="p">,</span><span class="w">
                </span><span class="s2">"' are longitude and latitude, respectively"</span><span class="p">)</span><span class="w">
      </span><span class="p">}</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'latitude'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">lats</span><span class="p">)))</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'longitude'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">lngs</span><span class="p">)))</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Couldn't infer longitude/latitude columns, please specify with 'lat'/'lon' parameters"</span><span class="p">,</span><span class="w"> </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">message</span><span class="p">(</span><span class="s2">"Using user input '"</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="s2">"' and '"</span><span class="p">,</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w">
            </span><span class="s2">"' as longitude and latitude, respectively"</span><span class="p">)</span><span class="w">
    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plyr</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'latitude'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">lat</span><span class="p">)))</span><span class="w">
    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plyr</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'longitude'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">lon</span><span class="p">)))</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">samp_date</span><span class="p">)){</span><span class="w">
    </span><span class="n">dates</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xnames</span><span class="p">[</span><span class="n">grep</span><span class="p">(</span><span class="s2">"date"</span><span class="p">,</span><span class="w"> </span><span class="n">xnames</span><span class="p">,</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)]</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">){</span><span class="w">
      </span><span class="k">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">2</span><span class="p">){</span><span class="w">
        </span><span class="n">message</span><span class="p">(</span><span class="s2">"Assuming '"</span><span class="p">,</span><span class="w"> </span><span class="n">dates</span><span class="p">,</span><span class="w"> </span><span class="s2">"' are sample dates"</span><span class="p">)</span><span class="w">
      </span><span class="p">}</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'date'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">dates</span><span class="p">)))</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">stop</span><span class="p">(</span><span class="s2">"Couldn't infer sample date column, please specify with 'date' parameter"</span><span class="p">,</span><span class="w"> </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">   
    
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">message</span><span class="p">(</span><span class="s2">"Using user input '"</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="p">,</span><span class="w"> </span><span class="s2">"' as sample date"</span><span class="p">)</span><span class="w">
    </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">plyr</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">setNames</span><span class="p">(</span><span class="s1">'date'</span><span class="p">,</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="n">samp_date</span><span class="p">)))</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>This extracts the relevant SST value for a given combination of latitude, longitude, and date. Note that it uses the <code class="language-plaintext highlighter-rouge">simple</code> (default) method for extracting values from the SST raster, in the <code class="language-plaintext highlighter-rouge">raster::extract</code> call. This means it simply extracts the SST value from the grid square in which each point falls. The <code class="language-plaintext highlighter-rouge">bilinear</code> method would interpolate SST values from the nearest 4 squares to a point. Likewise, it is possible to set buffers around each point and perform some function (e.g. mean) on all returned values. For environmental variables with little spatial autocorrelation these methods may be useful.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get_env_par_space_x_time</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="w">
  </span><span class="n">env_dat</span><span class="p">,</span><span class="w"> </span><span class="n">occ_dat</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.Date</span><span class="p">(</span><span class="s2">"1800-1-1"</span><span class="p">)){</span><span class="w">
  
  </span><span class="c1"># calculate starting julian day for each month in env_dat</span><span class="w">
  </span><span class="n">month_intervals</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">env_dat</span><span class="o">@</span><span class="n">z</span><span class="p">[[</span><span class="s2">"Date"</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">origin</span><span class="p">)</span><span class="w">
  </span><span class="c1"># calculate julian day for the focal date (eventDate in occ_dat)</span><span class="w">
  </span><span class="n">focal_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">occ_dat</span><span class="o">$</span><span class="n">date</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">origin</span><span class="p">)</span><span class="w">
  
  </span><span class="c1"># extract environmental variable (SST here) for this point</span><span class="w">
  </span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">raster</span><span class="o">::</span><span class="n">extract</span><span class="p">(</span><span class="w">
    </span><span class="n">env_dat</span><span class="p">,</span><span class="w">
    </span><span class="n">cbind</span><span class="p">(</span><span class="n">occ_dat</span><span class="o">$</span><span class="n">lon_adj</span><span class="p">,</span><span class="w"> </span><span class="n">occ_dat</span><span class="o">$</span><span class="n">latitude</span><span class="p">),</span><span class="w">
    </span><span class="n">layer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findInterval</span><span class="p">(</span><span class="n">focal_date</span><span class="p">,</span><span class="w"> </span><span class="n">month_intervals</span><span class="p">),</span><span class="w">
    </span><span class="n">nl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="w">
  </span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sst_prep</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"~/.spenv/noaa_sst"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">file.path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="s2">"sst.mnmean.nc"</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file.exists</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">dir.create</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">recursive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">showWarnings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
    </span><span class="n">download.file</span><span class="p">(</span><span class="s2">"ftp://ftp.cdc.noaa.gov/Datasets/noaa.oisst.v2/sst.mnmean.nc"</span><span class="p">,</span><span class="w"> </span><span class="n">destfile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">raster</span><span class="o">::</span><span class="n">brick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">varname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sst"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>So, we can add SST data to our sole occurrence data like this. Note that occurrence records with no date of collection information, or which were collected prior to 1981 (when the monthly mean dataset begins) will be stripped from the output. <strong>NB - SLOW!!!</strong> This takes ~11 minutes:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_sst</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sp_extract_gridded_date</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w">
                                    </span><span class="n">latitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"decimalLatitude"</span><span class="p">,</span><span class="w"> </span><span class="n">longitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"decimalLongitude"</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"eventDate"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Check dimensions of returned data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nrow</span><span class="p">(</span><span class="n">sole_sst</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 57880
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sum</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">yearcollected</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">1981</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 799
</code></pre></div></div>
<p>Quick plot of derived SST against lat and lon, for each month: first, extract the month from each date using <code class="language-plaintext highlighter-rouge">lubridate::month</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_sst</span><span class="o">$</span><span class="n">month</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">month</span><span class="p">(</span><span class="n">sole_sst</span><span class="o">$</span><span class="n">date</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Now plot occurrences by lon and lat, colour coded by temperature, faceted by month (1 = Jan to 12 = Dec):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">sole_sst_plot</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">ggplot</span><span class="p">(</span><span class="n">sole_sst</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">latitude</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">	
                     </span><span class="n">geom_point</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sst</span><span class="p">),</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                     </span><span class="n">scale_colour_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"red"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
                     </span><span class="n">facet_wrap</span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">month</span><span class="p">))</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot sole occxlatxlonxtemp-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>This looks reasonable - SST increases into the summer, and decreases with latitude.</p>

<p>The above matching process could be sped up by only querying for unique combinations of latitude, longitude, and date:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sum</span><span class="p">(</span><span class="o">!</span><span class="n">duplicated</span><span class="p">(</span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">,</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">eventDate</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 9480
</code></pre></div></div>
<p>Only 9480 unique combinations, of the nearly 60,000 occurrences. Aggregating to the resolution of the environmental dataset will likely reduce this further:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">lat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">)</span><span class="w">
</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">lon</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">)</span><span class="w">
</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">yr_month</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">paste</span><span class="p">(</span><span class="n">yearcollected</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">(</span><span class="n">eventDate</span><span class="p">),</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"_"</span><span class="p">))</span><span class="w">
</span><span class="nf">sum</span><span class="p">(</span><span class="o">!</span><span class="n">duplicated</span><span class="p">(</span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="n">yr_month</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 3539
</code></pre></div></div>
<p>Only 3539.</p>

<p>So: create a dataset with one example occurrence from each combination of lat, lon, and year_month:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_temp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="p">[</span><span class="o">!</span><span class="n">duplicated</span><span class="p">(</span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="n">yr_month</span><span class="p">)),</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="n">sole_sst2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sp_extract_gridded_date</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sole_temp</span><span class="p">,</span><span class="w">
                                     </span><span class="n">latitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"decimalLatitude"</span><span class="p">,</span><span class="w"> </span><span class="n">longitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"decimalLongitude"</span><span class="p">,</span><span class="w"> </span><span class="n">samp_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"eventDate"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>This now runs in ~40s, and results can be joined back into <code class="language-plaintext highlighter-rouge">sole_occs_refined</code>, based on a new location_date key:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_sst2</span><span class="o">$</span><span class="n">loc_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sole_sst2</span><span class="p">,</span><span class="w"> </span><span class="n">paste</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="n">yr_month</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"_"</span><span class="p">))</span><span class="w">
</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">loc_date</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">with</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">paste</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">lon</span><span class="p">,</span><span class="w"> </span><span class="n">yr_month</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"_"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Strip unwanted variables from <code class="language-plaintext highlighter-rouge">sole_sst</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_sst2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">sole_sst2</span><span class="p">,</span><span class="w"> </span><span class="n">loc_date</span><span class="p">,</span><span class="w"> </span><span class="n">sst</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Perform the join:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="n">sole_sst2</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"loc_date"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>And remove intermediate objects:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rm</span><span class="p">(</span><span class="n">sole_temp</span><span class="p">,</span><span class="w"> </span><span class="n">sole_sst2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Create month variable, using <code class="language-plaintext highlighter-rouge">lubridate::month</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">month</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">month</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">eventDate</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Recreate the lat-lon-temp-month plot from above:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_sst_plot</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">subset</span><span class="p">(</span><span class="w">
  </span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">sst</span><span class="p">)),</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">	
  </span><span class="n">geom_point</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sst</span><span class="p">),</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">scale_colour_gradient</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"red"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">facet_wrap</span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">month</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<p>The information collected now enables you to say something about the environmental conditions experienced by a species. For instance, we can show the range of temperatures experienced by sole, for instance getting a Tukey five-number summary (minimum, first quartile, median, third quartile, maximum):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fivenum</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">sst</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] -0.21 15.08 16.34 17.58 28.41
</code></pre></div></div>
<p>Or we could look at trends over years in the temperature experienced by sole, within each month:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">sole_sst_trends</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">subset</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="nf">is.na</span><span class="p">(</span><span class="n">sst</span><span class="p">)),</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yearcollected</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sst</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">	
   </span><span class="n">geom_point</span><span class="p">(</span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"steelblue"</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
   </span><span class="n">geom_smooth</span><span class="p">(</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"lm"</span><span class="p">,</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"darkorange"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
   </span><span class="n">facet_wrap</span><span class="p">(</span><span class="o">~</span><span class="w"> </span><span class="n">month</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/sole temp trends-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Note: these plots are purely exploratory. As we have already seen, sole are demersal fish and so sea bottom temperature is likely much more important to them than SST. And this plot takes no account of the spatial location of survey points in each year. But it serves to illustrate what is possible.</p>

<p><a class="anchor" name="local"></a></p>

<h3 id="matching-occurrences-to-local-spatial-datasets">Matching occurrences to local spatial datasets</h3>

<p>The examples above use R to obtain environmental data served over the web. However, there are also numerous spatial datasets that are not easily accessible via web services, that researchers may have either generated themselves, or have obtained from some third party and stored locally. Most frequently these kinds of data are available in some kind of gridded format. Here we provide examples of how to match occurrence records in space only to gridded data freely available from <a href="http://gmed.auckland.ac.nz/">GMED</a>, which we have downloaded to local files ASCII grid files.</p>

<p>Numerous gridded environmental layers are openly available, but they are not always easy to access remotely. For instance, the Global Marine Environment Dataset (GMED) provides time-averaged global layers of a wide range of environmental variables (see Basher, Z., Costello, M. J., Bowden, D. A. 2014. Global Marine Environment Dataset (GMED). World Wide Web electronic publication. Version 1.0 (Rev.01.2014). Accessed at http://gmed.auckland.ac.nz). However these are available as .7z zipped files, a Windows compression format that requires third party software (such as <a href="http://unarchiver.c3.cx/unarchiver">The Unarchiver</a>) to unzip on Mac OSX. The most straightforward approach then is to download and uncompress the files and then load them from a local source. The following  example uses the primary productivity data, which is read in as an ascii grid and then converted to a raster. You will need to copy the relevant folder into the data/ folder in your working directory, from <a href="https://drive.google.com/folderview?id=0B7OcGQ7KA64UQkFQWExUTGh0aU0&amp;usp=sharing">here</a>.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">read.asciigrid</span><span class="p">(</span><span class="s2">"data/primprod_chla/aq_primprod.asc"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>NB: this is rather a large (68.2MB) object:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">object_size</span><span class="p">(</span><span class="n">env_grid</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 68.2 MB
</code></pre></div></div>
<p>You can plot it to get an idea of the data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">env_grid</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot envgrid-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>And you can find e.g. the range of values present in the data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">range</span><span class="p">(</span><span class="n">env_grid</span><span class="o">@</span><span class="n">data</span><span class="o">@</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1]    0 4875
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">env_grid</span><span class="o">@</span><span class="n">data</span><span class="o">@</span><span class="n">values</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/range envgrid-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>And then you can extract values from environmental grid for occurrence points:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env_occ</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="n">extract</span><span class="p">(</span><span class="w">
  </span><span class="n">env_grid</span><span class="p">,</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w"> </span><span class="n">cellnumbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>
<p>Or simply add chla values directly back to the original dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">chla</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">env_grid</span><span class="p">,</span><span class="w">
                                  </span><span class="n">cbind</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>It is very quick to extract data from a flat raster so there is little to be gained from only querying unique lat-lon combinations here.</p>

<p>Another useful variable available from GMED is bottom temperature (although remember that it is a single long term time averaged layer, so is not directly comparable to the SST data we used above). You will need to add <a href="https://drive.google.com/folderview?id=0B7OcGQ7KA64UWjlGM2daaDV5LXc&amp;usp=sharing">this</a> to your data folder.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">env_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">read.asciigrid</span><span class="p">(</span><span class="s2">"data/btemp_k/kg_b_temp.asc"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Again, plot it to get an idea of the data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">env_grid</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot bottom temp-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>And you can find e.g. the range of values present in the data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">range</span><span class="p">(</span><span class="n">env_grid</span><span class="o">@</span><span class="n">data</span><span class="o">@</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] -2.08170 29.45666
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">env_grid</span><span class="o">@</span><span class="n">data</span><span class="o">@</span><span class="n">values</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/range bottom temp-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Add to <code class="language-plaintext highlighter-rouge">sole_occs_refined</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">bottom_temp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">env_grid</span><span class="p">,</span><span class="w">
                                         </span><span class="n">cbind</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Look at summary:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fivenum</span><span class="p">(</span><span class="n">sole_occs_refined</span><span class="o">$</span><span class="n">bottom_temp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1]  0.00000  9.94703 10.42849 10.80025 17.90282
</code></pre></div></div>

<hr />

<p><a class="anchor" name="geography"></a></p>

<h2 id="adding-geography">Adding geography</h2>

<p>All of the examples above have been global in scale, meaning that we have placed no spatial restrictions on the queries to OBIS - we have simply requested all occurrences that have been recorded anywhere on earth. However, we are frequently interested in sub-global analyses, either extracting data for an individual region of interest (such as a specific country’s EEZ), or summarising global data by region (e.g. records per regional sea). Here we show how the <a href="http://www.marineregions.org/">Marine Regions database</a> can be accessed programmatically to return OBIS data for a specific named region. We show how to get records for a specific taxon within a named region, or for all taxa within a named region. We also show how to summarise global data at the regional scale, for instance returning number of species or number of OBIS records per region.</p>

<p><a class="anchor" name="specificregion"></a></p>

<h3 id="getting-occurrence-data-for-a-specific-region">Getting occurrence data for a specific region</h3>

<p>All of the above work has been based on global data - we have extracted all records from OBIS, regardless of where in the world they come from. Often we have a particular focal region and want to get data only from there. The functions in robis allow such regions to be flexibly specified as a geometry argument in both occurrence and taxa. For instance you can explicitly specify the coordinates of a polygon. Here, we get occurrences of basking shark within the polygon bounded by 0 and -10 degrees longitude and by 50 and 60 degrees latitude:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basking_shark</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Cetorhinus maximus"</span><span class="p">,</span><span class="w">
                            </span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"POLYGON ((-10 50, -10 60, 0 60, 0 50, -10 50))"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basking_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">obis_map</span><span class="p">(</span><span class="n">basking_shark</span><span class="p">,</span><span class="w"> </span><span class="n">map_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">,</span><span class="w"> </span><span class="n">map_zoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">plotit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">F</span><span class="p">)</span><span class="w">
</span><span class="n">basking_map</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_rect</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">xmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="n">xmax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">ymin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">50</span><span class="p">,</span><span class="w"> </span><span class="n">ymax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">60</span><span class="p">),</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"green"</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/basking shark occurances by region ii-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>More often you are likely to want to specify some pre-existing region. <a href="http://marineregions.org">marineregions.org</a> provides a standard list of marine georeferenced place names and boundaries, including many regional specifications familiar to marine ecologists, such as Exclusive Economic Zones (EEZs), Large Marine Ecosystems (LMEs), IHO Regional Sea Areas, etc. The ROpenSci package <code class="language-plaintext highlighter-rouge">mregions</code> (vignette <a href="https://cran.r-project.org/web/packages/mregions/vignettes/mregions.html">here</a>) provides an interface to this database which allows us to provide specified polygons to OBIS when we query. If you know the name of the region of interest this is straightforward:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uk_eez</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_shp</span><span class="p">(</span><span class="s2">"MarineRegions:eez"</span><span class="p">,</span><span class="w"> </span><span class="n">maxFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"United Kingdom Exclusive Economic Zone"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>We’ll use <code class="language-plaintext highlighter-rouge">gSimplify</code> from <code class="language-plaintext highlighter-rouge">rgeos</code> to simplify the geometry a bit:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uk_eez_simple</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPolygonsDataFrame</span><span class="p">(</span><span class="n">gSimplify</span><span class="p">(</span><span class="n">uk_eez</span><span class="p">,</span><span class="w"> </span><span class="n">tol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.01</span><span class="p">,</span><span class="w"> </span><span class="n">topologyPreserve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uk_eez</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Use the <code class="language-plaintext highlighter-rouge">tidy</code> function in <code class="language-plaintext highlighter-rouge">broom</code> to convert this to a dataframe for plotting purposes:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uk_eez_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tidy</span><span class="p">(</span><span class="n">uk_eez_simple</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Re-run the OBIS query:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basking_shark</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">occurrence</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Cetorhinus maximus"</span><span class="p">,</span><span class="w">
                            </span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr_as_wkt</span><span class="p">(</span><span class="n">uk_eez_simple</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Reproduce the map:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basking_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">obis_map</span><span class="p">(</span><span class="n">basking_shark</span><span class="p">,</span><span class="w"> </span><span class="n">map_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"satellite"</span><span class="p">,</span><span class="w"> </span><span class="n">map_zoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">plotit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">F</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Plot the map together with the UK EEZ boundary (I have reduced the line width of bounding polygon here to 0.25):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">basking_map</span><span class="w"> </span><span class="o">+</span><span class="w">
  </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uk_eez_df</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">),</span><span class="w">
               </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"green"</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.25</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot shark with eez poly-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p><a class="anchor" name="specieslist"></a></p>

<h3 id="getting-a-species-list-for-a-specific-region">Getting a species list for a specific region</h3>

<p>The <code class="language-plaintext highlighter-rouge">checklist()</code> function can also take a geometry argument, making it straightforward to get, for instance, summary data for a particular species from within a given region, e.g.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uk_basking_shark</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">checklist</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Cetorhinus maximus"</span><span class="p">,</span><span class="w">
                         </span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr_as_wkt</span><span class="p">(</span><span class="n">uk_eez_simple</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Perhaps more useful is to get a taxon list for a region. The UK has an unusually large density of OBIS records so for a faster query we’ll use a different EEZ, here Albania. We’ll use the geo_json format instead of shape files here:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">geo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_geojson</span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"MarineRegions:eez"</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Albanian Exclusive Economic Zone"</span><span class="p">,</span><span class="w"> </span><span class="n">maxFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">)</span><span class="w">
</span><span class="n">alb_eez</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_as_wkt</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)</span><span class="w">
</span><span class="n">alb_taxa</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">checklist</span><span class="p">(</span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alb_eez</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>This returns a list of taxa, of various ranks. If we wanted a species list, we can get that easily:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alb_species</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">alb_taxa</span><span class="p">,</span><span class="w"> </span><span class="n">rank_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"Species"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This gives us a list of species recorded within the Albanian EEZ, together with useful taxonomic data and summary info as described in our first demonstration of the <code class="language-plaintext highlighter-rouge">checklist()</code> function above.</p>

<p><a class="anchor" name="regionnames"></a></p>

<h3 id="finding-appropriate-region-names">Finding appropriate region names</h3>

<p>The above examples assume that you already know the exact name of the region that interests you, but this is not always the case. You can of course check on marineregions.org, but mregions provides a number of functions to help you without having to leave R.</p>

<p>You can get a list of place types - different categories of regions:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reg_types</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_place_types</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>You can see all of the types like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sort</span><span class="p">(</span><span class="n">reg_types</span><span class="o">$</span><span class="n">type</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1] "Abyssal Plain"       "Abyssal Provinces"   "Anchorage"          
##  [4] "Apron"               "Aquifer"             "Archipelagic waters"
##  [7] "Archipelago"         "Arctic Marine Area"  "Area"               
## [10] "Arm"                
##  [ reached getOption("max.print") -- omitted 291 entries ]
</code></pre></div></div>
<p>EEZ is there, also things like FAO divisions, ICES Areas, Marine Ecoregions of the World, etc. To find region types matching a string of interest, try:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reg_types</span><span class="p">[</span><span class="n">grepl</span><span class="p">(</span><span class="s2">"IHO"</span><span class="p">,</span><span class="w"> </span><span class="n">reg_types</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##             type description
## 236 IHO Sea Area        &lt;NA&gt;
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reg_types</span><span class="p">[</span><span class="n">grepl</span><span class="p">(</span><span class="s2">"ICES"</span><span class="p">,</span><span class="w"> </span><span class="n">reg_types</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                            type
## 216              ICES Ecoregion
## 286                  ICES Areas
## 287 ICES Statistical Rectangles
##                                                                                                                                                                                                                                                 description
## 216          ICES EcoRegions are largescale management units that are used in ICES advisory reports and were first referenced in the ACFM/ACME report of 2004 (now ACOM) [http://www.ices.dk/datacentre/updates/DC_update.htm?WT.mc_id=DCeNews_March_2009].
## 286 The ICES Statistical Areas delineates the divisions and subdivisions of FAO Major Fishing area 27.\r\nThe ICES Statistical Areas are used as bounding areas for calculation of fish statistics, e.g. catch per unit effort (CPUE) and stock estimates. 
## 287                                                                                                                                                                                                                                                    &lt;NA&gt;
</code></pre></div></div>
<p>Note this is case insensitive:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reg_types</span><span class="p">[</span><span class="n">grepl</span><span class="p">(</span><span class="s2">"eez"</span><span class="p">,</span><span class="w"> </span><span class="n">reg_types</span><span class="p">[,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">ignore.case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                   type
## 64                 EEZ
## 297 Joint regime (EEZ)
##                                                                                                                                                                                                                                                                                                                                        description
## 64  In international maritime law, an exclusive economic zone (EEZ) is a seazone extending from a state's coast over which the state has special rights over the exploration and use of marine resources. Generally a state's EEZ extends 200 nautical miles out from its coast, except where resulting points would be closer to another country.
## 297                                                                                                                                                        A geographical area delimited by agreement between two or more countries where with specific arrangements in relation to the exploration and exploitation of natural marine resources.
</code></pre></div></div>
<p>Once you have the name of the type of region you want, you can get a list of all named regions under that scheme using, for example (and note this <em>is</em> case sensitive):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eez_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">mr_records_by_type</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"EEZ"</span><span class="p">))</span><span class="w">
</span><span class="n">iho_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">mr_records_by_type</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"IHO Sea Area"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>An issue here is that you are limited to returning only the first 100 features; for EEZs we know there are more than that. The following is a workaround:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">all_mr_records_by_type</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">mr_type</span><span class="p">){</span><span class="w">
  
  </span><span class="n">mr_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_records_by_type</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr_type</span><span class="p">)</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="n">nrow</span><span class="p">(</span><span class="n">mr_ids</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">100</span><span class="p">){</span><span class="w">
    </span><span class="n">new_q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">TRUE</span><span class="w">
    </span><span class="k">while</span><span class="p">(</span><span class="n">new_q</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">T</span><span class="p">){</span><span class="w">
      </span><span class="n">next_recs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_records_by_type</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr_type</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nrow</span><span class="p">(</span><span class="n">mr_ids</span><span class="p">))</span><span class="w">
      </span><span class="k">if</span><span class="p">(</span><span class="nf">length</span><span class="p">(</span><span class="n">next_recs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">){</span><span class="w">
        </span><span class="n">new_q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">mr_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rbind</span><span class="p">(</span><span class="n">mr_ids</span><span class="p">,</span><span class="w"> </span><span class="n">next_recs</span><span class="p">)</span><span class="w">
        </span><span class="k">if</span><span class="p">(</span><span class="n">nrow</span><span class="p">(</span><span class="n">eez_ids</span><span class="p">)</span><span class="w"> </span><span class="o">%%</span><span class="w"> </span><span class="m">100</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">){</span><span class="n">new_q</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">}</span><span class="w">				
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="nf">return</span><span class="p">(</span><span class="n">tbl_df</span><span class="p">(</span><span class="n">mr_ids</span><span class="p">))</span><span class="w">
  
</span><span class="p">}</span><span class="w">

</span><span class="n">eez_ids</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">all_mr_records_by_type</span><span class="p">(</span><span class="n">mr_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"EEZ"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>You can now find preferred names for all regions within the scheme (here, all individual EEZs) as:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sort</span><span class="p">(</span><span class="n">eez_ids</span><span class="o">$</span><span class="n">preferredGazetteerName</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1] "Albanian Exclusive Economic Zone"                                                                          
##  [2] "Algerian Exclusive Economic Zone"                                                                          
##  [3] "American Samoa Exclusive Economic Zone"                                                                    
##  [4] "Amsterdam Island &amp; St. Paul Island Exclusive Economic Zone"                                                
##  [5] "Angolan Exclusive Economic Zone"                                                                           
##  [6] "Anguilla Exclusive Economic Zone"                                                                          
##  [7] "Antarctic 200NM zone beyond the coastline"                                                                 
##  [8] "Antigua and Barbuda Exclusive Economic Zone"                                                               
##  [9] "Area of overlap between Australian Seabed Jurisdiction and Indonesian Exclusive Economic Zone Jurisdiction"
## [10] "Argentinean Exclusive Economic Zone"                                                                       
##  [ reached getOption("max.print") -- omitted 241 entries ]
</code></pre></div></div>
<p>And you can then feed this into the above, e.g.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tax_list</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">checklist</span><span class="p">(</span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr_as_wkt</span><span class="p">(</span><span class="n">mr_geojson</span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"MarineRegions:eez"</span><span class="p">,</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eez_ids</span><span class="o">$</span><span class="n">preferredGazetteerName</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">maxFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">),</span><span class="w"> </span><span class="n">fmt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>
<p>Add a <code class="language-plaintext highlighter-rouge">region_name</code> attribute for convenience:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">attr</span><span class="p">(</span><span class="n">tax_list</span><span class="p">,</span><span class="w"> </span><span class="s2">"region_name"</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">eez_ids</span><span class="o">$</span><span class="n">preferredGazetteerName</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>Check it:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">attr</span><span class="p">(</span><span class="n">tax_list</span><span class="p">,</span><span class="w"> </span><span class="s2">"region_name"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] "Belgian Exclusive Economic Zone"
</code></pre></div></div>

<p><a class="anchor" name="globaldata"></a></p>

<h3 id="summarising-global-data-by-region">Summarising global data by region</h3>

<p>Sometimes you may want summarise your occurrence data by region. We will do that for the occurrence data we generated above for full sorby collection list (<code class="language-plaintext highlighter-rouge">allspp_obis</code>), using IHO regional seas as our regions dataset.</p>

<p>We can download shape files for all regions within this scheme, but to do this we need to get the appropriate key for our scheme, which is slightly different from the type identified above. We can get a list of all scheme names using:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rnames</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_names</span><span class="p">()</span><span class="w">
</span></code></pre></div></div>
<p>And we can then search within this for anything containing IHO (case sensitive):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mr_names_search</span><span class="p">(</span><span class="n">rnames</span><span class="p">,</span><span class="w"> </span><span class="s2">"IHO"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## # A tibble: 5 × 4
##                                   name
##                                  &lt;chr&gt;
## 1                    MarineRegions:iho
## 2 MarineRegions:iho_quadrants_20150810
## 3                     World:iosregions
## 4       MarineRegions:eez_iho_union_v2
## 5                   Belgium:vl_venivon
## # ... with 3 more variables: title &lt;chr&gt;, name_first &lt;chr&gt;,
## #   name_second &lt;chr&gt;
</code></pre></div></div>
<p>We want the Marine Regions version of the IHO regions, <code class="language-plaintext highlighter-rouge">"MarineRegions:iho"</code>, which we can then use like this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_shp</span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"MarineRegions:iho"</span><span class="p">,</span><span class="w"> </span><span class="n">maxFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1000</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">maxFeatures</code> is the maximum number of features to download, with a default of 50. If you think your scheme may have more than 50 component features, but you’re not sure how many, set it to something arbitrarily large (e.g. here we have used 1000).</p>

<p>Also note other useful region schemas such as <code class="language-plaintext highlighter-rouge">World:grid5deg</code> - a 5 degree grid of the world:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wgrid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mr_shp</span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"World:grid5deg"</span><span class="p">,</span><span class="w"> </span><span class="n">maxFeatures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1000</span><span class="p">)</span><span class="w"> 
</span><span class="c1">#plot(wgrid)</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<p>This can be really useful for summarising occurrence data. You can browse through all region schemas using e.g.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sort</span><span class="p">(</span><span class="n">rnames</span><span class="o">$</span><span class="n">name</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>The following function allows you to plot these regions - it is not very polished but serves to show more or less where the regions are, and to identify any issues there may be. It takes a shape file similar to the one just generated as <code class="language-plaintext highlighter-rouge">iho_regions</code>, or a dataframe produced by applying the function <code class="language-plaintext highlighter-rouge">broom::tidy</code> to such a spatial polygons dataframe, and adds the regions to a world map. It will either colour the regions and provide a key (<code class="language-plaintext highlighter-rouge">poly_fill = TRUE</code>) or just plot their outlines (<code class="language-plaintext highlighter-rouge">poly_fill = FALSE</code>). <code class="language-plaintext highlighter-rouge">fill_by</code> allows polygons to be filled according to an additional variable, and is explained below.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span><span class="w"> </span><span class="n">poly_fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">fill_by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">plotit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">){</span><span class="w">
  
  </span><span class="c1"># get the base map</span><span class="w">
  </span><span class="n">base_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_data</span><span class="p">(</span><span class="s2">"world"</span><span class="p">)</span><span class="w">
  </span><span class="n">region_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ggplot</span><span class="p">(</span><span class="n">base_map</span><span class="p">,</span><span class="w"> </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="n">lat</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
    </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
    </span><span class="n">scale_y_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-2</span><span class="o">:</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">30</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
    </span><span class="n">scale_x_continuous</span><span class="p">(</span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">-4</span><span class="o">:</span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">45</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
    </span><span class="n">theme</span><span class="p">(</span><span class="n">panel.background</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_rect</span><span class="p">(</span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
    </span><span class="n">coord_equal</span><span class="p">()</span><span class="w">
  
  </span><span class="c1"># process the regions data into a dataframe, if necessary; add region names, and plot as polygons</span><span class="w">
  </span><span class="k">if</span><span class="p">(</span><span class="nf">class</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"SpatialPolygonsDataFrame"</span><span class="p">){</span><span class="w">
    </span><span class="n">regions</span><span class="o">@</span><span class="n">data</span><span class="o">$</span><span class="n">id_new</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">regions</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
    </span><span class="c1"># Create the dataframe</span><span class="w">
    </span><span class="n">regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tidy</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span><span class="w">
    </span><span class="c1"># Add missing info - specifically region name</span><span class="w">
    </span><span class="n">regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">regions_df</span><span class="p">,</span><span class="w"> </span><span class="n">regions</span><span class="o">@</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"id"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"id_new"</span><span class="p">))</span><span class="w">
    
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">regions</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">fill_by</span><span class="p">)){</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="n">poly_fill</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">){</span><span class="w">
      </span><span class="n">region_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">region_map</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regions_df</span><span class="p">,</span><span class="w">	
                     </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"top"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_text</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element_blank</span><span class="p">())</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">region_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">region_map</span><span class="w"> </span><span class="o">+</span><span class="w">
        </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regions_df</span><span class="p">,</span><span class="w">	
                     </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">),</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="n">colour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"green"</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">id_fill</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="nf">names</span><span class="p">(</span><span class="n">regions_df</span><span class="p">)</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="n">fill_by</span><span class="p">)</span><span class="w">
    </span><span class="nf">names</span><span class="p">(</span><span class="n">regions_df</span><span class="p">)[</span><span class="n">id_fill</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"fill_var"</span><span class="w">
    </span><span class="n">region_map</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">region_map</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">geom_polygon</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regions_df</span><span class="p">,</span><span class="w">	
                   </span><span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fill_var</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">scale_fill_gradient</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fill_by</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w">
      </span><span class="n">theme</span><span class="p">(</span><span class="n">legend.position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"top"</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  
  </span><span class="k">if</span><span class="p">(</span><span class="n">plotit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">){</span><span class="n">print</span><span class="p">(</span><span class="n">region_map</span><span class="p">)}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>As an example:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_map</span><span class="p">(</span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iho_regions</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/example regionmap-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Just plot region outlines:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_map</span><span class="p">(</span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iho_regions</span><span class="p">,</span><span class="w"> </span><span class="n">poly_fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot outlines regionmap-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>To identify the region in which each occurrence point in your occurrence dataset occurs, we need to do a little processing. First, we need to transform the occurrences into a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code>. This has to have the same projection as the regions shape file - for convenience here we will impose that condition, but for serious geospatial analyses more attention should be paid to projections.</p>

<p>For the purposes of illustration we will work on a sample of 10000 occurrence points:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">samp_obis</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sample_n</span><span class="p">(</span><span class="n">allspp_obis</span><span class="p">,</span><span class="w"> </span><span class="m">10000</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Create the spatial dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">samp_obis_spat</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="w">
  </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">samp_obis</span><span class="o">$</span><span class="n">decimalLongitude</span><span class="p">,</span><span class="w"> </span><span class="n">samp_obis</span><span class="o">$</span><span class="n">decimalLatitude</span><span class="p">),</span><span class="w">
  </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">samp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">proj4string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">iho_regions</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>Now for each point we can get the ID of the region in which it occurs:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allspp_obis_regionid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">over</span><span class="p">(</span><span class="n">samp_obis_spat</span><span class="p">,</span><span class="w"> </span><span class="n">iho_regions</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">allspp_obis_regionid</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##              name id mrgid
## 125747  North Sea  4  2350
## 675224   Kattegat  2  2374
## 942273  Skagerrak  3  2379
## 917531  Skagerrak  3  2379
## 1196617 North Sea  4  2350
## 1081563 North Sea  4  2350
</code></pre></div></div>
<p>This can now be added back into our original dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">samp_obis</span><span class="o">$</span><span class="n">iho_region</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">allspp_obis_regionid</span><span class="o">$</span><span class="n">name</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">samp_obis</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                scientificName decimalLongitude decimalLatitude depth
## 125747      Lanice conchilega        -2.966073        56.09899    NA
## 675224   Merlangius merlangus        11.866700        56.60000    31
## 942273  Pleuronectes platessa        10.732500        58.08380   227
## 917531  Pleuronectes platessa         9.166700        57.35000    20
## 1196617           Solea solea         2.715300        51.45780    29
## 1081563 Pleuronectes platessa         0.502500        57.24510    -9
##         yearcollected iho_region
## 125747           1993  North Sea
## 675224           1995   Kattegat
## 942273           2008  Skagerrak
## 917531           2002  Skagerrak
## 1196617          2009  North Sea
## 1081563          2009  North Sea
</code></pre></div></div>
<p>And region-level summaries can be obtained, for instance by grouping the data by <code class="language-plaintext highlighter-rouge">iho_region</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">by_region</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">group_by</span><span class="p">(</span><span class="n">samp_obis</span><span class="p">,</span><span class="w"> </span><span class="n">iho_region</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>This then gives total number of OBIS records, and number of species, for each <code class="language-plaintext highlighter-rouge">iho_region</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_summaries</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dplyr</span><span class="o">::</span><span class="n">summarise</span><span class="p">(</span><span class="n">by_region</span><span class="p">,</span><span class="w">
                                  </span><span class="n">n_obis_records</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">(),</span><span class="w">
                                  </span><span class="n">n_species</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_distinct</span><span class="p">(</span><span class="n">scientificName</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>By adding in more taxonomic information (or returning more of it from the original OBIS query), it would be possible to get higher taxon summaries too.</p>

<p>To put these summaries on a map, first convert the <code class="language-plaintext highlighter-rouge">iho_regions</code> data into a dataframe. This requires a little fiddling to ensure IDs match properly:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions</span><span class="o">@</span><span class="n">data</span><span class="o">$</span><span class="n">id_new</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rownames</span><span class="p">(</span><span class="n">iho_regions</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Create the dataframe:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tidy</span><span class="p">(</span><span class="n">iho_regions</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>And add missing info - specifically region name:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="p">,</span><span class="w"> </span><span class="n">iho_regions</span><span class="o">@</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"id"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"id_new"</span><span class="p">))</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##        long      lat order  hole piece group id
## 1 -6.496945 58.08749     1 FALSE     1   0.1  0
## 2 -6.513241 58.08596     2 FALSE     1   0.1  0
## 3 -6.529536 58.08444     3 FALSE     1   0.1  0
## 4 -6.545832 58.08291     4 FALSE     1   0.1  0
## 5 -6.562127 58.08138     5 FALSE     1   0.1  0
## 6 -6.578423 58.07985     6 FALSE     1   0.1  0
##                                        name id.y mrgid
## 1 Inner Seas off the West Coast of Scotland   18  4283
## 2 Inner Seas off the West Coast of Scotland   18  4283
## 3 Inner Seas off the West Coast of Scotland   18  4283
## 4 Inner Seas off the West Coast of Scotland   18  4283
## 5 Inner Seas off the West Coast of Scotland   18  4283
## 6 Inner Seas off the West Coast of Scotland   18  4283
</code></pre></div></div>
<p>Now add the summary data created above:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">left_join</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="p">,</span><span class="w"> </span><span class="n">iho_summaries</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"name"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"iho_region"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>
<p>This can now be plotted using the <code class="language-plaintext highlighter-rouge">region_map</code> function from above, now feeding in a <code class="language-plaintext highlighter-rouge">fill_by</code> argument:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_map</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="p">,</span><span class="w"> </span><span class="n">fill_by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"n_obis_records"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot region summaries-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Note that for our rather small sample, there will probably be a number of regions with no OBIS records or species here. But the principle is sound.</p>

<p>At present, if you wanted to plot, say, log-transformed number of records, you’d need to create a new variable in the dataframe, e.g.:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iho_regions_df</span><span class="o">$</span><span class="n">log_OBIS_records</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">log10</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="o">$</span><span class="n">n_obis_records</span><span class="p">)</span><span class="w">
</span><span class="n">region_map</span><span class="p">(</span><span class="n">iho_regions_df</span><span class="p">,</span><span class="w"> </span><span class="n">fill_by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"log_OBIS_records"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/create and map log number records-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p><a class="anchor" name="environmental"></a></p>

<h3 id="combining-regional-and-environmental-data">Combining Regional and Environmental Data</h3>

<p>We next show how regional and environmental data can be combined to return records from a particular environmental subset of a region. For instance, you might be interested only in parts of the North Atlantic that are &lt;500m deep, or you might want to focus on regions of the global oceans with an average bottom temperature above some minimum value. Once you have defined your area of interest based on such environmental constraints, you can then use the resulting polygon to return OBIS records.</p>

<p>Here we will take a large region, the North Atlantic Ocean IHO Sea Area. Get the North Atlantic polygon:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n_atlantic</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">subset</span><span class="p">(</span><span class="n">iho_regions</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"North Atlantic Ocean"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Have a look at it:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_map</span><span class="p">(</span><span class="n">n_atlantic</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/view natlantic poly-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Get its extent:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bb</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">bbox</span><span class="p">(</span><span class="n">n_atlantic</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Use <code class="language-plaintext highlighter-rouge">marmap</code> again to get bathymetry for this region - here using 10 min resolution for speed:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bathy</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">marmap</span><span class="o">::</span><span class="n">as.raster</span><span class="p">(</span><span class="w">
  </span><span class="n">getNOAA.bathy</span><span class="p">(</span><span class="w">
    </span><span class="n">lon1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bb</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lon2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bb</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
    </span><span class="n">lat1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bb</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lat2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bb</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w">
    </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">antimeridian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="w">
  </span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Quick look:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/quicklook natlantic poly-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Now, mask this bathymetry raster using the region polygon:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bathy</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">mask</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">n_atlantic</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/mask bathy by region poly-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>You can extract useful info here using <code class="language-plaintext highlighter-rouge">cellStats</code>, for instance the range of depths in your region:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cellStats</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] -8467  1089
</code></pre></div></div>
<p>And the number of ‘positive depths’ (indicating land):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cellStats</span><span class="p">(</span><span class="n">region_bathy</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 503
</code></pre></div></div>
<p>NB: the max value here is +1089, and 503 grid squares have values &gt; 0, presumably due to the resolution we used for bathymetry overlapping coastal areas, incorporating oceanic islands, etc.</p>

<p>You can find the number of cells meeting some set of criteria, e.g. lying in a particular depth range. First, set your criteria - here, cells between 0 and 500m deep:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mindepth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0</span><span class="w">
</span><span class="n">maxdepth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">-500</span><span class="w">
</span></code></pre></div></div>
<p>How many cells match this?</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cellStats</span><span class="p">(</span><span class="n">region_bathy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mindepth</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">region_bathy</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">maxdepth</span><span class="p">,</span><span class="w"> </span><span class="n">stat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 10362
</code></pre></div></div>
<p>10362 cells are in this range. To get the cell IDs (actually, this finds cells that do NOT match criteria, so they can be changed to NA):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id_out_of_depth</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">which</span><span class="p">(</span><span class="n">values</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxdepth</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">values</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">mindepth</span><span class="p">)</span><span class="w">
</span><span class="n">region_bathy_cut</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">region_bathy</span><span class="w">
</span><span class="n">region_bathy_cut</span><span class="p">[</span><span class="n">id_out_of_depth</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">NA</span><span class="w">
</span></code></pre></div></div>
<p>This now identifies all cells within the North Atlantic less then 500m deep:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">region_bathy_cut</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/view natlantic cells less than fivehundred m-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>To make matching to a new data source (e.g. occurrence data) easier, here is an alternative approach which creates a polygon out of cells matching the criteria. First, extract the part of the grid that matches your criteria - NB: this can be a bit slow:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bathy_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterToPolygons</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mindepth</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">maxdepth</span><span class="p">})</span><span class="w">
</span></code></pre></div></div>
<p>Plot if you like but this will take a long time to render when the number of polygons is large; much quicker to simplify by combining subgeometries using <code class="language-plaintext highlighter-rouge">rgeos::gUnaryUnion</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bathy_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">gUnaryUnion</span><span class="p">(</span><span class="n">region_bathy_poly</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">region_bathy_poly</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/plot ploy matching criteria-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>You now have a <code class="language-plaintext highlighter-rouge">spatialPolygon</code> outlining all suitable depths within your region, which you can use to extract values from another environmental raster - trivially (but again, rather slowly), for depth:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value_within_region</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bathy_poly</span><span class="p">,</span><span class="w"> </span><span class="n">df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">value_within_region</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   ID layer
## 1  1   -18
## 2  1   -21
## 3  1   -84
## 4  1  -185
## 5  1  -314
## 6  1  -214
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">names</span><span class="p">(</span><span class="n">value_within_region</span><span class="p">)[</span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"env_variable"</span><span class="w">
</span></code></pre></div></div>
<p>To check - all values here should be between <code class="language-plaintext highlighter-rouge">mindepth</code> and <code class="language-plaintext highlighter-rouge">maxdepth</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">range</span><span class="p">(</span><span class="n">value_within_region</span><span class="o">$</span><span class="n">env_variable</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] -500    0
</code></pre></div></div>
<p>Supposing you used a useful environmental variable in place of <code class="language-plaintext highlighter-rouge">region_bathy</code> here (e.g. Temperature) you can now easily get mean, range, sd, etc. NB: the environmental variable does not need to be the exact shape of your region - a global grid would work, e.g. the bottom temperature grid from GMED we used earlier:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bt_within_region</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">env_grid</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">region_bathy_poly</span><span class="p">,</span><span class="w"> </span><span class="n">df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">bt_within_region</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   ID data.btemp_k.kg_b_temp.asc
## 1  1                   2.275093
## 2  1                   2.269944
## 3  1                         NA
## 4  1                         NA
## 5  1                   2.250614
## 6  1                   1.911228
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fivenum</span><span class="p">(</span><span class="n">bt_within_region</span><span class="p">[,</span><span class="m">2</span><span class="p">])</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] -2.081700  4.552719  7.994298 14.232640 28.531600
</code></pre></div></div>
<p>Of course you can also use this method of finding ‘environmentally suitable areas’ directly on gridded data (in raster format), e.g. to find those areas globally with a bottom temperature &gt;15 degrees:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">min_bt_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterToPolygons</span><span class="p">(</span><span class="n">env_grid</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">15</span><span class="p">})</span><span class="w">
</span><span class="n">min_bt_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">gUnaryUnion</span><span class="p">(</span><span class="n">min_bt_poly</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">min_bt_poly</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/areas greater than fifteen deg-1.png" style="display: block; margin: auto;" /></p>

<p><br /></p>

<p>Polygons defined in this way (providing they are not too complex) can then be fed into OBIS queries. (For more complex polygons it is probably easier to query OBIS with a simple bounding box and then crop the returned occurrences to your polygon within R). For instance, to get a list of fish species occurring in water of 1000m or more depth in the North Atlantic (note, the depth constraint here is bottom depth, not sample depth). These queries can take a long time to run if polygons are large and/or complex, or if the taxonomic group queried is speciose. The mammal query here takes around 1.5 minutes for me to run:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">region_bathy_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterToPolygons</span><span class="p">(</span><span class="n">region_bathy</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">){</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">-1000</span><span class="p">})</span><span class="w">
</span><span class="n">region_bathy_poly</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">gUnaryUnion</span><span class="p">(</span><span class="n">region_bathy_poly</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">region_bathy_poly</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="/images/sorbycollection/mammal bathy plot-1.png" style="display: block; margin: auto;" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deep_mammals</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">checklist</span><span class="p">(</span><span class="n">scientificname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Mammalia"</span><span class="p">,</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">writeWKT</span><span class="p">(</span><span class="n">region_bathy_poly</span><span class="p">))</span><span class="w">
</span><span class="n">deep_mammals</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tbl_df</span><span class="p">(</span><span class="n">subset</span><span class="p">(</span><span class="n">deep_mammals</span><span class="p">,</span><span class="w"> </span><span class="n">rank_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"Species"</span><span class="p">))</span><span class="w">
</span><span class="n">deep_mammals</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## # A tibble: 43 × 17
##        id valid_id parent_id rank_name                      tname
## *   &lt;int&gt;    &lt;int&gt;     &lt;int&gt;     &lt;chr&gt;                      &lt;chr&gt;
## 1  409229   409229    769778   Species         Balaena mysticetus
## 2  409235   409235    739484   Species      Balaenoptera borealis
## 3  409238   409238    739484   Species      Balaenoptera musculus
## 4  409240   409240    739484   Species      Balaenoptera physalus
## 5  432569   432569    769784   Species      Delphinapterus leucas
## 6  432575   432575    432573   Species          Delphinus delphis
## 7  443716   443716    443715   Species           Feresa attenuata
## 8  446724   446724    629011   Species Globicephala macrorhynchus
## 9  446726   446726    629011   Species         Globicephala melas
## 10 448800   448800    448799   Species            Grampus griseus
## # ... with 33 more rows, and 12 more variables: tauthor &lt;chr&gt;,
## #   worms_id &lt;int&gt;, redlist &lt;lgl&gt;, status &lt;chr&gt;, records &lt;int&gt;,
## #   datasets &lt;int&gt;, phylum &lt;chr&gt;, order &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;,
## #   species &lt;chr&gt;, class &lt;chr&gt;
</code></pre></div></div>

<p><br /></p>

<p>So, 43 species of marine mammal have been recorded in deep water in the North Atlantic.</p>

<hr />

<p><a class="anchor" name="coda"></a></p>

<h2 id="coda">Coda</h2>

<p>Nothing in biodiversity research stands still. New data sources are continually coming online. For instance, <a href="http://www.marinespecies.org/">WoRMS</a> has now started to integrate information on the biological traits of marine organisms into its taxonomic database, in its <a href="http://www.marinespecies.org/traits/">new traits site</a>. These should be available via web services soon, and we aim to show how to integrate these kinds of data into the above work flows. And just to prove that a job is never done, whilst writing this the displays in <a href="http://www.sheffield.ac.uk/aps">Animal &amp; Plant Science</a> have been undergoing work, and the spectacular new version of the Sorby Collection has just been unveiled. So - more species, more data, more work. Onwards!</p>

<p><img src="/images/sorbycollection/adb3.png" alt="" /></p>

<p><br /></p>

<hr />
<p>This post was supported by the <a href="http://www.iode.org/index.php?option=com_content&amp;view=article&amp;id=470&amp;Itemid=100216">DIPS-4-Ocean Assessments project</a>, funded through the Flanders UNESCO Science Trust Fund, which aims to develop biodiversity indices based on OBIS to support global assessments on the state of the marine environment.</p>

<p><img src="/images/flanders_logo.jpg" width="" /></p>

<hr />

    </div>

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JBW0JFMNBJ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-JBW0JFMNBJ');
</script>
  </body>
</html>